# 0.基础

## 0.脚本定义

- 内嵌脚本

  像style标签一样，可以在 html 文档中使用 script 标签嵌入JavaScript代码

  ```js
  <script>
      alert("小杰不菜");
  </script>
  ```

- 外部文件

  通过设置 src 属性引入外部 js 文件

  ```js
  <script src="fengbao.js"></script>
  ```

## 1.避免延迟

- 如果 js 放在 <heade> 标签中，要等到 js 加载并解析后才会显示 <body> 标签中的内容

## 2.代码注释

- 单行注释

  ```js
  <script>
      // 这是单行注释
  </script>
  ```

- 多行注释

  ```js
  <script>
     /*
    	  这是多行注释体验
    */
  </script>
  ```

## 3.变量声明

- js 中的变量是弱类型，可以保存所有类型的数据，即变量没有类型而值有类型。变量名以字母、$、_ 开头，后跟字母、数字、_ 。js 语言关键字不能用来做变量名。

- 可以使用多种方式定义变量，比如var、let等

  ```js
  let name = 'fengbao';
  ```

- 使用 , 可以同时声明多个变量

  ```js
  let n = 2, f = 3;
  console.log(f);
  ```

- 变量可以更换不同类型的数据，变量类型由所引用的值决定

  ```js
  let xj = 'fengbao';
  console.log(typeof xj);	// string
  
  xj = 20;
  console.log(typeof xj);  // number
  ```

- 变量提升

  解析器会先解析代码，然后把变量的声明提升到最前面，这就叫做变量提升。

  使用 var 声明代码会被提升到前面，赋值还在原位置

  ```js
  console.log(a); // undefined
  var a = 1;
  console.log(a);  // 1
  
  // 以上代码解析器执行过程如下
  var a;
  console.log(a); // undefined
  a = 1;
  console.log(a); // 1
  ```

- TDZ

  TDZ 又称暂时性死区，指变量在作用域内已经存在，但必须在 let/const 声明以后才可以使用。

  TDZ 可以让程序保持先声明后使用的习惯，让程序更稳定。

  - 变量要先声明后使用
  - 建议使用 let/const 而少使用 var

  - 使用 let/const 声明的变量在声明前存在临时性死区（TDZ），使用会发生错误

  ```js
  console.log(x); // Cannot access 'x' before initialization
  let x = 1;
  ```

  - 在 run 函数作用域中产生 TDZ ，不允许变量在未声明前使用

  ```js
  xj = "fengbao";
  function run() {
    console.log(xj);
    let xj = "zhangsan";
  }
  run();  // Cannot access 'xj' before initialization
  ```

  - b 没有声明赋值不允许直接使用

    ```js
    function xj(a = b, b = 3) {}
    xj(); //Cannot access 'b' before initialization
    ```

  - a 已经赋值，所以 b 可以使用 a 变量，下面代码访问正常

    ```js
    function xj(a = 2, b = a) {}
    xj();
    ```

## 4.块作用域

- 共同点

  - var/let/const 共同点是全局作用域中定义的变量，可以在函数中使用
  - 函数中声明的变量，只能在函数及其子函数中使用
  - 函数中声明的变量就像声明了私有领地，外部无法访问

- var

  使用 var 声明的变量存在与最近的函数或全局作用域中，没有块作用域的机制。

  - 没有块作用域很容易污染全局

  - 使用 let 有块作用域时则不会

  - var 全局声明的变量也存在于 window 对象中

    ```js
    var xj = "fengbao";
    console.log(window.xj); // fengbao
    ```

- let

  与 var 声明的区别是 let/const 拥有块作用域

  - 建议将 let 在代码块前声明
  - 用逗号分隔定义多个
  - let 存在块作用域特性，变量只在块作用域中有效
  - 块内部是可以访问到上层作用域的变量
  - 每一层都是独立作用域，里层作用域可以声明外层作用域的同名变量，但不会改变外层变量

- const

  使用 const 来声明常量，这与其它语言差别不大

  - 只能声明一次变量
  - 声明时必须同时赋值
  - 不允许再次全新赋值
  - 可以修改引用类型变量的值
  - 拥有块、函数、全局作用域

- 重复定义

  - 使用 var 可能造成不小心定义同名变量
  - 使用 let 可以避免上面的问题，因为 let 声明后的变量不允许在同一作用域中重新声明
  - let 全局声明的变量不存在于 window 对象中，这与 var 声明不同

- Object.freeze

  如果冻结变量后，变量也不可以修改了，使用严格模式会报出错误

  ```js
  "use strict"
  const INFO = {
    url: 'https://www.houdunren.com',
    port: '8080'
  };
  Object.freeze(INFO);
  INFO.port = '443'; // Cannot assign to read only property 'port' of object '#<Object>'
  console.log(INFO);
  ```

- 传值与传址

  基本数据类型指数值、字符串等简单数据类型，引用类型指对象数据类型

  - 基本类型复制是值的复制，互相不受影响。下列中将 a 变量的值赋值给 b 变量后，因为基本类型变量是独立的所以 a 色改变不会影响 b 变量的值

    ```js
    let a = 100;
    let b = a;
    a = 200;
    console.log(b);	// 100
    ```

  - 对于引用类型来讲，变量保存的是引用对象的指针。变量间赋值时其实赋的值时变量的指针，这样多个变量引用的是同一个对象

    ```js
    let a = {
      web: "小杰"
    };
    let b = a;
    a.web = "fengbao";
    console.log(b); // {web: "fengbao"}
    ```

## 5.undefined

- 对声明但未赋值的变量返回类型为 undefined ，表示值未定义

  ```js
  let xj;
  console.log(typeof xj); // undefined
  ```

- 对未声明的变量使用会报错，但判断类型将显示 undefined

  ```js
  console.log(typeof xj); // undefined
  console.log(xj);  // xj is not defined
  ```

- 函数无实参或无返回值为 undefined

  ```js
  function xj(web) {
    console.log(web); //undefined
    return web;
  }
  console.log(xj()); //undefined
  ```

- null

  null 用于定义一个空对象，即如果变量要用来保存引用类型，可以在初始化是将其设置为 null

## 6.严格模式

严格模式可以让我们及早发现错误，使代码更安全规范，推荐在代码中一直保持严格模式运行。

- 基本差异

  变量必须使用管家此声明，未声明的变量不允许赋值

  ```js
  "use strict";
  url = 'fengbao'; //url is not defined
  ```

  强制声明防止污染全局

  关键词不允许做变量使用

  变量参数不允许重复定义

  可以单独为函数设置严格模式

  ```js
  function strict(){  
    "use strict";  
    return "严格模式";  
  }  
  function notStrict() {  
    return "正常模式";  
  }  
  ```

- 解构差异

  非严格模式可以不使用声明指令，严格模式下必须使用声明


# 1.运算符与流程控制

## 0.运算符

- 赋值运算符

  使用 = 进行变量赋值

- 算术运算符

  \+ , - , * , / , %

- 复合运算符

  *= ， /= , += , -= , %=

- 一元运算符

  在表达式最先执行 ++n ， --n

  在表达式最后执行 n++ , n--

- 比较运算符

  \> , <  , >= , <= , ==

- 逻辑运算符

  && , || , !

## 1.流程控制

- if

- if else

- 三元表达式

  ? :

  a ? b : c 若 a 为真，则返回 b ， 否则，返回 c

- switch

  可以将 switch 理解为 if 的另一种结构清晰的写法

  - 如果表达式等于 case 中的值，将执行此 case 代码段
  - break 关键字会终止 switch 的执行
  - 没有任何 case 匹配时将执行 default 代码块
  - 如果 case 执行后缺少 break 则接着执行后面的语句

  ```js
  let name = '视频';
  switch (name) {
      case '产品':
          console.log('xj.com');
          break;
      case '视频':
          console.log('fengbao.com');
          break;
      default:
          console.log('laoA.com')
  }
  ```

  css 合用示例

  ```js
  let error = 'warning';
  switch (error) {
    case 'notice':
    case 'warning':
        console.log('警告或提示信息');
        break;
    case 'error':
        console.log('错误信息');
  }
  ```

  在 switch 与 css 中都可以使用表达式 

  ```js
  function message(age) {
    switch (true) {
      case age < 15:
        console.log("儿童");
        break;
      case age < 25:
        console.log("青少年");
        break;
      case age < 40:
        console.log("青年");
        break;
      case age < 60:
        console.log("中年");
        break;
      case age < 100:
        console.log("老年");
        break;
      default:
        console.log("年龄输出错误");
    }
  }
  message(10);
  ```

  缺少 break 后，会接着执行后面的 switch 代码

  ```js
  switch (1) {
    case 1:
      console.log(1);
    case 2:
      console.log(2);
    default:
      console.log("default");
  }
  ```

- while

  循环执行语句，需设置跳出循环条件，否则会变成死循环

- do/while

  后条件判断语句，无论条件是否为真都会先进行循环体

- for

  可以在循环前初始化计算变量

  ```js
  for (let i = 10; i > 0; i--) {
      for (let n = 0; n < i; n++) {
          document.write('*');
      }
      document.write("<br/>");
  }
  ```

- break/continue

  break 用于退出当前循环，continue 用于退出当前循环返回当前循环起始继续执行

  - 获取所有偶数

    ```js
    for (let i = 1; i <= 10; i++) {
      if (i % 2) continue;
      console.log(i);  // 2, 4, 6, 8, 10
    }
    ```

  - 获取三个奇数

    ```js
    let count = 0,num = 3;
    for (let i = 1; i <= 10; i++) {
      if (i % 2) {
        console.log(i);  // 1, 3, 5
        if (++count == num) break;
      }
    }
    ```

- label

  标签 label 为程序定义位置，可以使用 continue/break 跳到该位置

  ```js
  // i+n 大于15时退出循环
  fengbao: for (let i = 1; i <= 10; i++) {
    xj: for (let n = 1; n <= 10; n++) {
      if (n % 2 != 0) {
        continue xj;
      }
      console.log(i, n);
      if (i + n > 15) {
        break fengbao;
      }
    }
  }
  ```

- for/in

  用于遍历对象的所有属性， for/in 主要用于遍历对象，不建议用来遍历数组

  ```js
  let info = {
    name: "小杰",
    url: "fengbao.com"
  };
  for (const key in info) {
    if (info.hasOwnProperty(key)) {
      console.log(info[key]);	 // 小杰  fengbao
    }
  }
  ```

- for/of

  用来遍历 Arrays (数组)，String (字符串)， Maps(映射)，Sets(集合)等可迭代的数据结构

  与 for/in 不同的是 for/of 每次循环取其中的值而不是索引

  - 遍历字符串

    ```js
    let str = 'fengbao';
    for (const iterator of str) {
        console.log(iterator);  // x i a o j i e
    }
    ```

  - 遍历数组

    ```js
    const hd = ["xj", "fengbao"];
    
    for (const [key, value] of hd.entries()) {
      console.log(key, value); // 0 "xj"   1 "fengbao"
    }
    ```

  - 遍历DOM元素

    ```js
    <body>
      <ul>
        <li></li>
        <li></li>
      </ul>
    </body>
    <script>
      let lis = document.querySelectorAll("li");
      for (const li of lis) {
        li.addEventListener("click", function() {
          this.style.backgroundColor = "red";
        });
      }
    </script>
    ```

# 2.基本类型

## 0.类型检测

- typeof

  typeof 用于返回以下原始类型

  - 基本类型： number/string/boolean
  - function
  - object
  - undefined

  可以使用 typeof 判断数据类型

  ```js
  let a = 1;
  console.log(typeof a); //number
  
  let b = "1";
  console.log(typeof b); //string
  
  //未赋值或不存在的变量返回undefined
  var xj;
  console.log(typeof xj);	// undefined
  
  function run() {}
  console.log(typeof run); //function
  
  let c = [1, 2, 3];
  console.log(typeof c); //object
  
  let d = { name: "fengbao.com" };
  console.log(typeof d); //object
  ```

- instanceof

  instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上

  也可以理解为是否为某个对象的实例， typeof 不能区分数组，但 instanceof 可以

  ```js
  let xj = [];
  let fengbao = {};
  console.log(xj instanceof Array); //true
  console.log(fengbao instanceof Array); //false
  
  let c = [1, 2, 3];
  console.log(c instanceof Array); //true
  
  let d = { name: "fengbao.com" };
  console.log(d instanceof Object); //true
  
  function User() {}
  let hd = new User();
  console.log(hd instanceof User); //true
  ```

- 值类型与对象

  ```js
  let xj = "fengbao";
  let bc = new String("bucai"); 
  console.log(typeof xj, typeof bc); //string object
  ```

  只有对象才有方法使用，但在 js 中也可以使用值类型调用方法，因为他会在执行时将值类型转换为对象

  ```js
  let xj = "fengbao";
  let bc = new String("bucai");
  console.log(xj.length); // 7
  console.log(bc.length); // 5
  ```

## 1.String

- 声明定义

  使用对象形式创建字符串

  ```js
  const xj = new String("fengbao");
  console.log(xj.length);   // 7
  // 获取字符串
  console.log(xj.toString());   // fengbao
  ```

  字符串使用单、双引号包裹，单、双引号使用结果没有区别

- 转义符号

  有些字符有双层含义，需要使用 \ 转义字符进行含义转换

  ```js
  const xj = "小杰\'不菜\'";
  console.log(xj);    // 小杰'不菜'
  ```

  \t , \n , \\\ , \\' , \\"

- 连接运算符

  使用 + 可以连接多个内容组合成字符串，经常用于组合输出内容使用

  ```js
  const name = '小杰';
  const age = 20;
  console.log(name + '今年' + age);   // 小杰今年20
  ```

  使用 += 在字符串上追回字符内容

  ```js
  let name = '小杰';
  name += '不菜';
  console.log(name);   // 小杰不菜
  ```

- 模板字面量

  使用\`,,,\`符号包裹的字符串中可以引入变量与表达式

  ```js
  const name = '小杰';
  console.log(`我叫${name}`);   // 我叫小杰
  ```

  支持换行操作不会产生错误

  ```js
  const name = '小杰';
  document.write(`我叫${name}，
  今年20`); 
  ```

  使用表达式

  ```js
  function xj() {
    return '小杰';
  } 
  console.log(`${xj()}`);   // 小杰
  ```

  支持嵌套使用

  ```js
  let lessons = [
  	{title: '媒体查询响应式布局'},
      {title: 'FLEX 弹性盒模型'},		
      {title: 'GRID 栅格系统'}
  ];
  
  function template() {
    return `<ul>
        ${lessons.map((item)=>`
            <li>${item.title}</li>
        `).join('')}
    </ul>`;
  }
  document.body.innerHTML = template();
  ```

- 标签模板

  标签模板是提取出普通字符串与变量，交由标签函数处理

  ```js
  let lesson = 'css';
  let web = '小杰';
  tag `访问${web}学习${lesson}前端知识`;
  
  function tag(strings, ...values) {
      console.log(strings); //["访问", "学习", "前端知识"]
      console.log(values); // ["小杰", "css"]
  }
  ```

  ```js
  // 将标题中有风暴游戏的加上链接
  let lessons = [
    { title: "风暴游戏媒体查询响应式布局", author: "风暴游戏小杰" },
    { title: "FLEX 弹性盒模型", author: "风暴游戏" },
    { title: "GRID 栅格系统风暴游戏教程", author: "小杰" }
  ];
  
  function links(strings, ...vars) {
    return strings
      .map((str, key) => {
        return (
          str +
          (vars[key]
            ? vars[key].replace(
                "风暴游戏",
                `<a href="https://www.fengbaogame.com">风暴游戏</a>`
              )
            : "")
        ); 
      })
      .join("");
  }
  
  function template() {
    return `<ul>
      ${lessons
        .map(item => links`<li>${item.author}:${item.title}</li>`)
        .join("")}
  </ul>`;
  }
  document.body.innerHTML += template();
  ```

- 获取长度

  使用 length 属性可以获取字符串长度

  ```js
  console.log("fengbaogame.com".length) // 15
  ```

- 大小写转换

  将字符转成大写字符

  ```js
  console.log("fengbaogame.com".toUpperCase()); // FENGBAOGAME.COM
  ```

  将字符转成小写字符

  ```js
  console.log("FENGBAOGAME.COM".toLowerCase()); // fengbaogame.com
  ```

- 移除空白

  使用 trim() 删除字符串左右的空白字符

  ```js
  let str = "   fengbaogame.com  ";
  console.log(str.length);  // 20
  console.log(str.trim().length); // 15
  ```

  使用 trimLeft 删除左边空白，trimRight 删除右边空白

  ```js
  let str = "   fengbaogame.com  ";
  console.log(str.length);  // 20
  console.log(str.trimLeft().length); // 17
  console.log(str.trimRight().length); // 18
  ```

- 获取单字符

  根据从 0 开始的位置获取字符

  ```js
  console.log("fengbaogame".charAt(4));  // b
  ```

  使用数字索引获取字符串

  ```js
  console.log("fengbaogame"[4]);  // b
  ```

- 截取字符串

  使用 slice、substr、substring 函数都可以截取字符串

  - slice、substring 第二个参数为截取的结束位置
  - substr 第二个参数指定获取字符数量

  ```js
  let fb = 'fengbaogame.com';
  console.log(fb.slice(3)); //gbaogame.com
  console.log(fb.substr(3)); //gbaogame.com
  console.log(fb.substring(3)); //gbaogame.com
  
  console.log(fb.slice(3, 6)); //gba
  console.log(fb.substring(3, 6)); //gba
  console.log(fb.substring(3, 0)); //fen 较小的做为起始位置
  console.log(fb.substr(3, 6)); //gbaoga
  
  console.log(fb.slice(3, -1)); //gbaogame.co 第二个为负数表示从后面算的字符
  console.log(fb.slice(-2));//om 从末尾取
  console.log(fb.substring(3, -9)); //fen 负数转为0
  console.log(fb.substr(-3, 2)); //co 从后面第三个开始取两个
  ```

- 查找字符串

  从开始获取字符串位置，检测不到返回 -1

  ```js
  console.log('fengbaogame.com'.indexOf('o')); // 6
  console.log('fengbaogame.com'.indexOf('o', 8)); //13 从第9个字符向后搜索
  ```

  从结尾来搜索字符串位置

  ```js
  console.log('fengbaogame.com'.lastIndexOf('o')); // 13
  console.log('fengbaogame.com'.lastIndexOf('o', 7)); // 6 从第8个字符向前搜索
  ```

  search() 方法用于检索字符串中指定的子字符串，也可以使用正则表达式搜索

  ```js
  let str = "fengbaogame.com";
  console.log(str.search("com"));   // 12
  console.log(str.search(/\.com/i));    // 11
  ```

  includes 字符串中是否包含指定的值，第二个参数指查找开始位置

  ```js
  console.log('fengbaogame.com'.includes('o')); //true
  console.log('fengbaogame.com'.includes('g', 4)); //true
  ```

  startsWith 是否是指定字符串开始，第二个参数为查找的开始位置

  ```js
  console.log('fengbaogame.com'.startsWith('f')); // true
  console.log('fengbaogame.com'.startsWith('o', 8)); // false
  ```

  endsWith 是否是指定字符串结束，第二个参数为查找的结束位置

  ```js
  console.log('fengbaogame.com'.endsWith('f')); // false
  console.log('fengbaogame.com'.endsWith('g', 8)); // true
  ```

- 替换字符串

  replace 方法用于字符串的替换操作
  
  ```js
  let name = "fengbaogame.com";
  let web = name.replace("fengbaogame", "fbgame");
  console.log(name);    // fengbaogame.com
  console.log(web);  // fbgame.com
  ```
  
  默认只替换一次如果全局替换需要使用正则
  
  ```js
  let str = "2023/02/12";
  console.log(str.replace(/\//g, "-"));   // 2023-02-12
  ```
  
  使用字符串替换生成关键词链接
  
  ```js
  const word = ["php", "css"];
  const string = "我喜欢学习php与css知识";
  const title = word.reduce((pre, word) => {
    return pre.replace(word, `<a href="?w=${word}">${word}</a>`);
  }, string);
  document.body.innerHTML += title;
  ```
  
  使用正则表达式完成替换
  
  ```js
  let res = "fengbaogame.com".replace(/g/g, str => {
    return "@";
  });
  console.log(res);   // fen@bao@ame.com
  ```
  
- 重复生成

  根据参数重复生成星号

  ```js
  function star(num = 3) {
  	return '*'.repeat(num);
  }
  console.log(star());    // ***
  ```

  模糊后三位电话号码

  ```js
  let phone = "15518556343";
  console.log(phone.slice(0, -3) + "*".repeat(3));  // 15518556***
  ```

- 类型转换

  分隔字母

  ```js
  let name = "fbgame";
  console.log(name.split(""));  // ['f', 'b', 'g', 'a', 'm', 'e']
  ```

  将字符串转换为数组

  ```js
  console.log("1,2,3".split(",")); // ['1', '2', '3']
  ```

  隐式类型转换会根据类型自动转换类型

  ```js
  let fb = 99 + '';
  console.log(typeof fb);  // string
  ```

  使用 `String` 构造函数可以显示转换字符串类型

  ```js
  let fb = 99;
  console.log(typeof String(fb));  // string
  ```

  js中大部分类型都是对象，可以使用类方法 `toString`转化为字符串

  ```js
  let fb = 99;
  console.log(typeof fb.toString());    // string
  
  let arr = ["风暴游戏", 'fbgame'];
  console.log(typeof arr.toString());   // string
  ```

## 2.Boolean

布尔类型包括 `true` 与 `false` 两个值，开发中使用较多的数据类型。

- 声明定义

  使用对象形式创建布尔类型

  ```js
  console.log(new Boolean(true));   // Boolean {true}
  console.log(new Boolean(false));   // Boolean {false}
  ```

  建议使用字面量创建布尔类型

  ```js
  let fb = true;
  console.log(fb);  // true
  ```

- 隐式转换

  基本上所有类型都可以隐式转换为 Boolean类型

  | 数据类型  |       true       |      false       |
  | :-------: | :--------------: | :--------------: |
  |  String   |    非空字符串    |     空字符串     |
  |  Number   |    非0的数值     |     0 、NaN      |
  |   Array   | 数组不参与比较时 | 参与比较的空数组 |
  |  Object   |     所有对象     |                  |
  | undefined |        无        |    undefined     |
  |   null    |        无        |       null       |
  |    NaN    |        无        |       NaN        |

  当与boolean类型比较时，会将两边类型统一为数字1或0

  如果使用Boolean与数值比较时，会进行隐式类型转换 ，true转为1，false 转为0

  ```js
  console.log(3 == true);   // false
  console.log(0 == false);    // true
  console.log(0 === false);    // false
  ```

  字符串在与Boolean比较时，两边都为转换为数值类型后再进行比较

  ```js
  console.log(Number("fbgame"));  // NaN
  console.log(Boolean("fbgame"));   // true
  console.log("fbgame" == true);    // false
  console.log("1" == true);   // true
  ```

  数组的表现与字符串原理一样，会先转换为数值

  ```js
  console.log(Number([])); //0
  console.log(Number([3])); //3
  console.log(Number([1, 2, 3])); //NaN
  console.log([] == false); //true
  console.log([1] == true); //true
  console.log([1, 2, 3] == true); //false
  ```

  引用类型的Boolean值为真，如对象和数组

  ```js
  if ([]) console.log("true");    // true
  if ({}) console.log("true");    // true
  ```

- 显示转换

  使用 !! 转换布尔类型

  ```js
  let fb = '';
  console.log(!!fb); //false
  fb = 0;
  console.log(!!fb); //false
  fb = null;
  console.log(!!fb); //false
  fb = new Date("2020-2-22 10:33");
  console.log(!!fb); //true
  ```

  使用 `Boolean` 函数可以显式转换为布尔类型

  ```js
  let fb = '';
  console.log(Boolean(fb)); //false
  fb = 0;
  console.log(Boolean(fb)); //false
  fb = null;
  console.log(Boolean(fb)); //false
  fb = new Date("2020-2-22 10:33");
  console.log(Boolean(fb)); //true
  ```

- 实例操作

  使用Boolean类型判断用户的输入，并给出不同的反馈。

  ```js
  while (true) {
    let n = prompt("请输入风暴游戏成立年份").trim();
    if (!n) continue;
    alert(n == 2020 ? "回答正确" : `答案错误！看看官网了解下`);
    break;
  }
  ```

## 3.Number

- 声明定义

  使用对象方式声明

  ```js
  let fb = new Number(1);
  console.log(fb + 2);    // 3
  ```

  Number 用于表示整数和浮点数，数字是 `Number`实例化的对象，可以使用对象提供丰富的方法。

  ```js
  let num = 20;
  console.log(typeof num);    // number
  ```

- 基本函数

  判断是否为整数

  ```js
  console.log(Number.isInteger(1.4));   // false
  ```

  指定返回的小数位数可以四舍五入

  ```js
  console.log((17.88.toFixed(1)));    // 17.9
  ```

- NaN

  表示无效的数值

  ```js
  console.log(Number("fengbao"));   // NaN
  console.log(2 / "fbgame");    // NaN
  ```

  NaN不能使用 == 比较

  ```js
  var res = 2 / 'fbgame';
  if(Number.isNaN(res)) {
    console.log('Error');   // Error
  }
  ```

  也可以使用 `Object.is` 方法判断两个值是否完全相同

  ```js
  var res = 2 / 'fbgame';
  console.log(Object.is(res, NaN));   // true
  ```

- 类型转换

  Number

  - 使用 Number 函数基本上可以转换所有类型

    ```js
    console.log(Number('fengbaogame')); //NaN
    console.log(Number(true));	//1
    console.log(Number(false));	//0
    console.log(Number('9'));	//9
    console.log(Number([]));	//0
    console.log(Number([5]));	//5
    console.log(Number([5, 2]));	//NaN
    console.log(Number({}));	//NaN
    ```

  - parseInt

    提取字符串开始去除空白后的数字转为整数

    ```js
    console.log(parseInt('  99houdunren'));	//99
    console.log(parseInt('18.55'));	//18
    ```

  - parseFloat

    转换字符串为浮点数，忽略字符串前面空白字符

    ```js
    console.log(parseFloat('  99houdunren'));	//99
    console.log(parseFloat('18.55'));	//18.55
    ```

  从表单获取的数字是字符串类型，需要类型转换才可以计算，下面使用乘法进行隐式类型转换

  ```js
  <body>
    <input type="text" name="num" value="66">
  </body>
  <script>
    let num = document.querySelector("[name='num']").value;
    console.log(num + 5); //665
  
    console.log(num * 1 + 5); //71
  </script>
  ```

- 舍入操作

  使用 `toFixed` 可对数值舍入操作，参数指定保存的小数位

  ```js
  console.log(1.5546.toFixed(2));   // 1.55 
  ```

- 浮点精度

  大部分编程语言在浮点数计算时都会有精度误差问题

  ```js
  let fb = 0.1 + 0.2
  console.log(fb);    //  0.30000000000000004
  ```

  这是因为计算机以二进制处理数值类型，上面的0.1与0.2转为二进制后是无穷的

  ```js
  console.log((0.1).toString(2)) //0.0001100110011001100110011001100110011001100110011001101
  console.log((0.2).toString(2)) //0.001100110011001100110011001100110011001100110011001101
  ```

  - 处理方式

    使用toFixed 方法进行小数截取

    ```js
    console.log((0.1 + 0.2).toFixed(2));    // 0.30
    
    console.log(1.0 - 0.9);   // 0.09999999999999998
    console.log((1.0 - 0.9).toFixed(2));    // 0.10
    ```

    将小数转为整数进行计算后，再转为小数也可以解决精度问题

    ```js
    Number.prototype.add = function (num) {
    	//取两个数值中小数位最大的
      let n1 = this.toString().split('.')[1].length
      let n2 = num.toString().split('.')[1].length
      
      //得到10的N次幂
      let m = Math.pow(10, Math.max(n1, n2))
    
      return (this * m + num * m) / m
    }
    console.log((0.1).add(0.2))   // 0.3
    ```

  - 推荐做法

    使用 decimal.js 进行浮点计算

    ```js
    <script src="https://cdn.bootcss.com/decimal.js/10.2.0/decimal.min.js"></script>
    
    <script>
    	console.log(Decimal.add(0.1, 0.2).valueOf())
    </script>
    ```

## 4.Math

`Math` 对象提供了众多方法用来进行数学计算

- 取极限值

  使用 `min` 与 `max` 可以取得最小与最大值

  ```js
  console.log(Math.min(1, 2, 3));   // 1
  console.log(Math.max(1, 2, 3));   // 3
  ```

  使用`apply` 来从数组中取值

  ```js
  console.log(Math.max.apply(Math, [1, 2, 3]));   // 3
  ```

- 舍入处理

  取最接近的向上整数

  ```js
  console.log(Math.ceil(1.111)); //2
  ```

  得到最接近的向下整数

  ```js
  console.log(Math.floor(1.555)); //1
  ```

  四舍五入处理

  ```js
  console.log(Math.round(1.5)); //2
  ```

- random

  `random` 方法用于返回 >=0 且 <1 的随机数（包括0但不包括1）

  返回0~5的随机数，不包括5

  ```js
  const number = Math.floor(Math.random() * 5);
  console.log(number);
  ```

  返回0~5的随机数，包括5

  ```js
  const number = Math.floor(Math.random() * (5+1));
  console.log(number);
  ```

  取2~5的随机数（不包括5）公式为：min+Math.floor(Math.random()*(Max-min))

  ```js
  const number = Math.floor(Math.random() * (5 - 2)) + 2;
  console.log(number);
  ```

  取2~5的随机数（包括5）公式为：min+Math.floor(Math.random()*(Max-min+1))

  ```js
  const number = Math.floor(Math.random() * (5 - 2 + 1)) + 2;
  console.log(number);
  ```

  随机点名

  ```js
  let stus = ['小明', '张三', '王五', '爱情'];
  let pos = Math.floor(Math.random() * stus.length);
  console.log(stus[pos]);
  ```

  随机取第二到第三间的学生，即1~2的值

  ```js
  let stus = ['小明', '张三', '王五', '爱情'];
  let pos = Math.floor(Math.random() * (3-1)) + 1;
  console.log(stus[pos]);
  ```

## 5.Data

处理日期时间是很常用的功能，通过 `Date` 类型提供的丰富功能可以非常方便的操作

- 声明日期

  获取当前日期时间

  ```js
  let now = new Date();
  console.log(now); // Sat Sep 04 2021 11:10:40 GMT+0800 (中国标准时间)
  console.log(typeof now);  // object
  console.log(now * 1); // 1630725040053
  
  //直接使用函数获取当前时间
  console.log(Date());  // Sat Sep 04 2021 11:11:48 GMT+0800 (中国标准时间)
  console.log(typeof Date()); //string
  
  //获取当前时间戳单位毫秒
  console.log(Date.now());  // 1630725108519
  
  ```

  计算脚本执行时间

  ```js
  const start = Date.now();
  for (let i = 0; i < 2000000; i++) {}
  const end = Date.now();
  console.log(end - start);
  ```

  也可以使用控制台测试

  ```js
  console.time("testFor");
  for (let i = 0; i < 20000000; i++) {}
  console.timeEnd("testFor");
  ```

  根据指定的日期与时间定义日期对象

  ```js
  let now = new Date('2028-02-22 03:25:02');
  console.log(now); // Tue Feb 22 2028 03:25:02 GMT+0800 (中国标准时间)
  
  now = new Date(2028, 4, 5, 1, 22, 16);
  console.log(now); // Fri May 05 2028 01:22:16 GMT+0800 (中国标准时间)
  ```

  使用展示运算符处理更方便

  ```js
  let info = [2021, 9, 4, 11, 17, 32];
  let date = new Date(...info);
  console.dir(date);  // Mon Oct 04 2021 11:17:32 GMT+0800 (中国标准时间)
  ```

- 类型转换

  将日期转为数值类型就是转为时间戳，单位是毫秒

  ```js
  let fb = new Date("2020-9-4 11:19:12");
  console.log(fb * 1);  // 1599189552000
  
  console.log(Number(fb));  // 1599189552000
  
  console.log(fb.valueOf())  // 1599189552000
  
  console.log(fb.getTime());  // 1599189552000
  ```

  将时间戳转换为标准日期的方法

  ```js
  const param = [1990, 2, 22, 13, 22, 19];
  const date = new Date(...param);
  const timestamp = date.getTime();
  console.log(timestamp);   // 638083339000
  console.log(new Date(timestamp));   // Thu Mar 22 1990 13:22:19 GMT+0800 (中国标准时间)
  ```

- 对象方法

  格式化输出日期

  ```js
  let time = new Date();
  console.log(
    `${time.getFullYear()}-${time.getMonth() + 1}-${time.getDate()} ${time.getHours()}:${time.getMinutes()}:${time.getSeconds()}`
  );  // 2021-9-4 11:26:47
  ```

  封装函数用于复用

  ```js
  function dateFormat(date, format = "YYYY-MM-DD HH:mm:ss") {
    const config = {
      YYYY: date.getFullYear(),
      MM: date.getMonth() + 1,
      DD: date.getDate(),
      HH: date.getHours(),
      mm: date.getMinutes(),
      ss: date.getSeconds()
    };
    for (const key in config) {
      format = format.replace(key, config[key]);
    }
    return format;
  }
  console.log(dateFormat(new Date(), "YYYY年MM月DD日"));  // 2021年9月4日
  ```

  |     方法      |                    描述                     |
  | :-----------: | :-----------------------------------------: |
  |    Date()     |           返回当日的日期和时间。            |
  |   getDate()   | 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 |
  |   getDay()    |  从 Date 对象返回一周中的某一天 (0 ~ 6)。   |
  |  getMonth()   |       从 Date 对象返回月份 (0 ~ 11)。       |
  | getFullYear() |      从 Date 对象以四位数字返回年份。       |
  |  getHours()   |       返回 Date 对象的小时 (0 ~ 23)。       |
  | getMinutes()  |       返回 Date 对象的分钟 (0 ~ 59)。       |
  | getSeconds()  |       返回 Date 对象的秒数 (0 ~ 59)。       |
  |   getTime()   |    返回 1970 年 1 月 1 日至今的毫秒数。     |

- ### moment.js

  Moment.js是一个轻量级的JavaScript时间库，它方便了日常开发中对时间的操作，提高了开发效率

# 3.数组类型

## 0.声明数组

数组是多个变量值的集合，数组是`Array` 对象的实例，所以可以像对象一样调用方法

- 创建数组

  使用对象方式创建数组
  
  ```js
  console.log(new Array(1, '风暴游戏', 'fbgame'));  // [1, '风暴游戏', 'fbgame']
  ```
  
  使用字面量创建是推荐的简单作法
  
  ```js
  const array = ["fbgame", "xj"];
  ```
  
  多维数组定义
  
  ```js
  const array = [["fbgame"], ["xj"]];
  console.log(array[1][0]);   // xj
  ```
  
  数组是引用类型可以使用`const`声明并修改它的值
  
  ```js
  const array = ["fbgame", "xj"];
  array.push("小杰");
  console.log(array);   // ['fbgame', 'xj', '小杰']
  ```
  
  使用原型的 `length`属性可以获取数组元素数量
  
  ```js
  let fb = ['风暴游戏', 'xj'];
  console.log(fb.length);   // 2
  ```
  
  数组可以设置任何值；使用索引添加数组
  
  ```js
  let fb = ['风暴游戏'];
  fb[1] = 333;
  console.log(fb);  // ['风暴游戏', 333]
  ```
  
  ```js
  // 直接设置3号数组，会将1/2索引的数组定义为空值
  let fb = ['风暴游戏'];
  fb[3] = 333;
  console.log(fb);  // ['风暴游戏', empty × 2, 333]
  ```
  
  声明多个空元素的数组
  
  ```js
  let fb = new Array(2);
  console.log(fb.length);   // 2
  console.log(fb);    // [empty × 2]
  ```
  
- Array.of

  使用`Array.of` 与 `new Array` 不同的是设置一个参数时不会创建空元素数组

  ```js
  let fb = Array.of(2);
  console.log(fb.length);   // 1
  console.log(fb);    // [2]
  ```

- 类型检测

  检测变量是否为数组类型

  ```js
  console.log(Array.isArray([1, 'fengbao']));   // true
  console.log(Array.isArray(9));   // false
  ```

## 1.类型转换

可以将数组转换为字符串也可以将其他类型转换为数组

- 字符串

  大部分数据类型都可以使用`.toString()` 函数转换为字符串

  ```js
  console.log(([1, 2, 3]).toString());  // 1,2,3
  ```

  也可以使用函数 `String` 转换为字符串

  ```js
  console.log(String([1, 2, 3]));  // 1,2,3
  ```

  或使用`join`连接为字符串

  ```js
  console.log([1, 2, 3].join("-"));  // 1-2-3
  ```

- Array.from

  使用`Array.from`可将类数组转换为数组，类数组指包含 `length` 属性或可迭代的对象

  第一个参数为要转换的数据，第二个参数为类似于`map` 函数的回调方法

  ```js
  let str = '风暴游戏';
  console.log(Array.from(str));  // ['风', '暴', '游', '戏']
  ```

  为对象设置`length`属性后也可以转换为数组，但要下标为数值或数值字符串

  ```js
  let user = {
    0: "小杰",
    "1": 22,
    length: 2
  };
  console.log(Array.from(user));    // ['小杰', 22]
  ```

  DOM元素转换为数组后来使用数组函数，第二个参数类似于`map` 函数的方法，可对数组元素执行函数处理

  ```js
  </body>
      <button message="风暴游戏">button</button>
      <button message="fbgame">button</button>
  </body>
  <script>
  "use strict"
  let btns = document.querySelectorAll('button');
      console.log(btns); // [button, button]
      Array.from(btns, (item) => {
          item.style.background = 'red';
      });
  </script>
  ```

  使用展开语法将 `NodeList` 转换为数组操作

  ```js
  <style>
      .hide {
        display: none;
      }
  </style>
  
  <body>
    <div>fbgame</div>
    <div>风暴游戏</div>
  </body>
  
  <script>
    let divs = document.querySelectorAll("div");
    [...divs].map(function(div) {
      div.addEventListener("click", function() {
        this.classList.toggle("hide");
      });
    });
  </script>
  ```

## 2.展开语法

- 数组合并

  使用展开语法来合并数组相比 `concat` 要更简单，使用`...` 可将数组展开为多个值

  ```js
  let a = [1, 2, 3];
  let b = ['风暴游戏', 'fbgame', ...a];
  console.log(b);   // ['风暴游戏', 'fbgame', 1, 2, 3]
  ```

- 函数参数

  使用展示语法可以替代 `arguments` 来接收任意数量的参数

  ```js
  function fb(...args) {
    console.log(args);
  }
  fb([1, 2, '小杰']);   // [Array(3)]
  ```

  也可以用于接收部分参数

  ```js
  function fb(site, ...args) {
    console.log(site, args);
  }
  fb('小杰', 1, 2, 'fengbao');    // 小杰 (3) [1, 2, 'fengbao']
  ```

- 节点转换

  可以将DOM节点转为数组，下面例子不可以使用 filter 因为是节点列表

  ```js
  <body>
    <button message="风暴游戏">button</button>
    <button message="fbgame">button</button>
  </body>
  
  <script>
      let btns = document.querySelectorAll('button');
      btns.filter((item) => {
          console.log(item); //TypeError: btns.filter is not a function
      })
  </script>
  ```

  使用展开语法后就可以使用数据方法

  ```js
  <body>
    <div>fbgame</div>
    <div>小杰</div>
  </body>
  
  <script>
    let divs = document.querySelectorAll("div");
    [...divs].map(function(div) {
      div.addEventListener("click", function() {
        this.style.color = 'red';
      });
    });
  </script>
  ```

## 3.解构赋值

解构是一种更简洁的赋值特性，可以理解为分解一个数据的结构

- 基本使用

  基本使用方法

  ```js
  // 数组使用
  let [name, age] = ['小杰', 22];
  console.log(name, age);   // 小杰 22
  ```

  解构赋值数组

  ```js
  function fb() {
    return ['风暴数组', 1, 2];
  }
  let [a, b] = fb();
  console.log(a, b);    // 风暴数组 1
  ```

  剩余解构指用一个变量来接收剩余参数

  ```js
  let [a, ...b] = [25, '风暴游戏', 'xiaojie'];
  console.log(a, b);    // 25 (2) ['风暴游戏', 'xiaojie']
  ```

  如果变量已经初始化过，就要使用`()` 定义赋值表达式，严格模式会报错所以不建议使用

  ```js
  let web = "风暴", url;
  [web, url] = ["fbgame.com", "fengbaogame.com"];
  console.log(web);   // fbgame.com
  ```

  字符串解构

  ```js
  const [...a] = "fengbaogame";
  console.log(a);   // ['f', 'e', 'n', 'g', 'b', 'a', 'o', 'g', 'a', 'm', 'e']
  ```

- 严格模式

  非严格模式可以不使用声明指令，严格模式下必须使用声明。所以建议使用 let 等声明

- 简洁定义

  只赋值变量部分

  ```js
  let [,url] = ['xj', '小杰'];
  console.log(url);   // 小杰
  ```

  使用展开语法获取多个值

  ```js
  let [name, ...url] = ['xj', '小杰', '风暴'];
  console.log(name, url);   // xj (2) ['小杰', '风暴']
  ```

- 默认值

  为变量设置默认值

  ```js
  let [name, url = 'fbgame'] = ['小杰'];
  console.log(name, url);   // 小杰 fbgame
  ```

- 函数参数

  数组参数的使用

  ```js
  function fb([a, b]) {
    console.log(a, b);
  }
  fb([1, "风暴游戏"]);  // 1 '风暴游戏'
  ```

## 4.管理元素

- 基本使用

  使用从0开始的索引来改变数组
  
  ```js
  let arr = [1, "风暴游戏", "fbgame"];
  arr[1] = '风暴游戏工作室';
  console.log(arr); //[1, "风暴游戏工作室", "fbgame"]
  ```
  
  向数组追回元素
  
  ```js
  let arr = [1, "风暴游戏", "fbgame"];
  arr[arr.length] = 'fengbaogame.com';
  console.log(arr); //[1, "后盾人", "fbgame", "fengbaogame.com"]
  ```
  
- 扩展语法

  ```js
  let arr = ["风暴游戏", "fbgame"];
  let hd = ["fengbaogame"];
  hd.push(...arr);
  console.log(hd); //["fengbaogame", "风暴游戏", "fbgame"]
  ```

- push

  压入元素，直接改变元数组，返回值为数组元素数量

  ```js
  let arr = ["风暴游戏", "fbgame"];
  console.log(arr.push('小杰', 'fengbaogame')); //4
  console.log(arr); //["风暴游戏", "fbgame", "小杰", "fengbaogame"]
  ```

  根据区间创建新数组

  ```js
  function rangeArray(begin, end) {
    const array = [];
    for (let i = begin; i <= end; i++) {
      array.push(i);
    }
    return array;
  }
  console.log(rangeArray(1, 6));  // [1, 2, 3, 4, 5, 6]
  ```

- pop

  从末尾弹出元素，直接改变元数组，返回值为弹出的元素

  ```js
  let arr = ["风暴游戏", "fbgame"];
  console.log(arr.pop()); //fbgame
  console.log(arr); //["风暴游戏"]
  ```

- shift

  从数组前面取出一个元素

  ```js
  let arr = ["风暴游戏", "fbgame"];
  console.log(arr.shift()); //风暴游戏
  console.log(arr); //["fbgame"]
  ```

- unshift

  从数组前面添加元素

  ```js
  let arr = ["风暴游戏", "fbgame"];
  console.log(arr.unshift('小杰', 'fengbaogame')); //4
  console.log(arr); //["小杰", "fengbaogame", "风暴游戏", "fbgame"]
  ```

- fill

  使用 fill 填充数组元素

  ```js
  console.dir(Array(3).fill("风暴游戏")); //["风暴游戏", "风暴游戏", "风暴游戏"]
  ```

  指定填充位置

  ```js
  console.log([1, 2, 3, 4].fill("风暴游戏", 1, 2)); //[1, "风暴游戏", 3, 4]
  ```

- slice

  使用 `slice` 方法从数组中截取部分元素组合成新数组（并不会改变原数组），不传第二个参数时截取到数组的最后元素

  ```js
  let arr = [0, 1, 2, 3, 4, 5, 6];
  console.log(arr.slice(1, 3)); // [1,2]
  ```

  不设置参数是为获取所有元素

  ```js
  let arr = [0, 1, 2, 3, 4, 5, 6];
  console.log(arr.slice()); //[0, 1, 2, 3, 4, 5, 6]
  ```

- splice

  使用 `splice` 方法可以添加、删除、替换数组中的元素，会对原数组进行改变，返回值为删除的元素。

  删除数组元素第一个参数为从哪开始删除，第二个参数为删除的数量

  ```js
  let arr = [0, 1, 2, 3, 4, 5, 6];
  console.log(arr.splice(1, 3)); //返回删除的元素 [1, 2, 3] 
  console.log(arr); //删除数据后的原数组 [0, 4, 5, 6]
  ```

  通过修改`length`删除最后一个元素

  ```js
  let arr = ["风暴游戏", "fbgame", "小杰"];
  arr.length = arr.length - 1;
  console.log(arr);   // ["风暴游戏", "fbgame"]
  ```

  通过指定第三个参数来设置在删除位置添加的元素

  ```js
  let arr = [0, 1, 2, 3, 4, 5, 6];
  console.log(arr.splice(1, 3, 'fbgame', '风暴游戏')); //[1, 2, 3]
  console.log(arr); //[0, "fbgame", "风暴游戏", 4, 5, 6]
  ```

  向末尾添加元素

  ```js
  let arr = [0, 1, 2, 3, 4, 5, 6];
  console.log(arr.splice(arr.length, 0, 'fbgame', '风暴游戏')); //[]
  console.log(arr); // [0, 1, 2, 3, 4, 5, 6, "fbgame", "风暴游戏"]
  ```

  向数组前添加元素

  ```js
  let arr = [0, 1, 2, 3, 4, 5, 6];
  console.log(arr.splice(0, 0, 'fbgame', '风暴游戏')); //[]
  console.log(arr); //["fbgame", "风暴游戏", 0, 1, 2, 3, 4, 5, 6]
  ```

  数组元素位置调整函数

  ```js
  function move(array, before, to) {
    if (before < 0 || to >= array.length) {
      console.error("指定位置错误");
      return;
    }
    const newArray = [...array];
    const elem = newArray.splice(before, 1);
    newArray.splice(to, 0, ...elem);
    return newArray;
  }
  const array = [1, 2, 3, 4];
  console.table(move(array, 0, 3));
  ```

- 清空数组

  将数组值修改为`[]`可以清空数组，如果有多个引用时数组在内存中存在被其他变量引用

  ```js
  let user = [{ name: "fbgame" }, { name: "风暴游戏" }];
  let cms = user;
  user = [];
  console.log(user);  // []
  console.log(cms);   // [{…}, {…}]
  ```

  将数组`length`设置为0也可以清空数组

  ```js
  let user = [{ name: "fbgame" }, { name: "风暴游戏" }];
  user.length = 0;
  console.log(user);    // []
  ```

  使用`splice`方法删除所有数组元素

  ```js
  let user = [{ name: "fbgame" }, { name: "风暴游戏" }];
  user.splice(0, user.length);
  console.log(user);    // []
  ```

  使用`pop/shift`删除所有元素，来清空数组

  ```js
  let user = [{ name: "fbgame" }, { name: "风暴游戏" }];
  while (user.pop()) {}
  console.log(user);    // []
  ```

## 5.合并拆分



## 6.查找元素

## 7.数组排序

## 8.循环遍历

## 9.迭代器方法

## 10.values

## 11.扩展方法

# 4.Symbol

# 5.Set

# 6.Map

# 7.函数进阶

# 8.作用域与闭包

# 9.对象

## 0.基础知识

对象是包括属性与方法的数据类型，js中大部分类型都是对象，如 String，Number，Math，RegExp，Data等

- 面向过程编程

  ```js
  let name = "小杰";
  let grade = [
    { lesson: "js", score: 99 },
    { lesson: "mysql", score: 85 }
  ];
  function average(grade, name) {
    const total = grade.reduce((t, a) => t + a.score, 0);
    return name + ":" + total / grade.length + "分";
  }
  console.log(average(grade, name));  // 小杰:92分
  ```

- 面向对象编程

  使用对象变成的代码结构清晰，减少了函数的参数传递，也不用担心函数名的覆盖

  ```js
  let user = {
    name: "小杰",
    grade: [
      { lesson: "js", score: 99 },
      { lesson: "mysql", score: 85 }
    ],
    average() {
      let total = this.grade.reduce((t, a) => t + a.score, 0);
      return this.name + ":" + total / this.grade.length + "分";
    }
  };
  console.log(user.average());  // 小杰:92分
  ```

- OOP

  - 对象是属性和方法的集合，即封装
  - 将复杂功能隐藏在内部，只开放给外部少量方法，更改对象内部的复杂逻辑不会对外部调用造成影响，即抽象
  - 继承是通过代码复用减少冗余代码
  - 根据不同形态的对象产生不同结果，即多态

- 基本声明

  使用字面量形式声明对象是最简单的方式

  ```js
  let obj = {
    name: '小杰',
    get:function() {
    	return this.name;
    }
  }
  console.log(obj.get()); // 小杰
  ```

  属性与方法的简写

  ```js
  let name = "小杰";
  let obj = {
    name,
    get() {
      return this.name;
    }
  };
  console.log(obj.get()); // 小杰
  ```

  字面量形式在系统内部也是使用构造函数 new Object 创建的

- 操作属性

  使用点语法获取

  ```js
  let user = {
    name: "小杰"
  };
  console.log(user.name);   // 小杰
  ```

  使用 [ ] 获取

  ```js
  let user = {
    name: "小杰"
  };
  console.log(user["name"]);   // 小杰
  ```

  使用 . 操作属性更简洁，[ ] 主要用于通过变量定义属性的场景

  ```js
  let user = {
    name: "小杰"
  };
  let property = "name";
  console.log(user[property]);  // 小杰
  ```

  如果属性名不是合法变量名就必须使用括号的形式了

  ```js
  let user = {};
  user["my-age"] = 28;
  console.log(user["my-age"]);  // 28
  ```

  对象和方法的属性可以动态的添加或删除

  ```js
  const xj = {
    name: "小杰"
  };
  xj.age = "20";
  xj.show = function() {
    return `${this.name}已经${this.age}岁了`;
  };
  console.log(xj.show()); // 小杰已经20岁了
  console.log(xj);  // {name: "小杰", age: "20", show: ƒ}
  
  delete xj.show;
  delete xj.age;
  
  console.log(xj);  // {name: "小杰"}
  console.log(xj.age); //undefined
  ```

- 对象方法

  定义在对象中的函数我们称为方法

  ```js
  let lisi = {
    name: "李四",
    age: 22,
    grade: {
      math: 99,
      english: 67
    },
    //平均成绩
    avgGrade: function() {
      let total = 0;
      for (const key in this.grade) {
        total += this.grade[key];
      }
      return total / this.propertyCount("grade");
    },
    //获取属性数量
    propertyCount: function(property) {
      let count = 0;
      for (const key in this[property]) count++;
      return count;
    }
  };
  console.log(lisi.avgGrade()); // 83
  ```

- 引用特性

  对象和函数，数组一样是引用类型，即复制只会复制引用地址

  ```js
  let xj = { name: "小杰" };
  let fb = xj;
  fb.name = "fengbao";
  console.log(xj.name); // fengbao
  ```

  对象作为函数参数使用时也不会产生完全赋值，内外共用一个对象

  ```js
  let user = { age: 22 };
  function xj(user) {
    user.age += 10;
  }
  xj(user);
  console.log(user.age); // 32
  ```

  对象的比较是内存地址的比较，所以使用 == 或 === 一样

  ```js
  let fb = {};
  let xj = fb;
  let fbyx = {};
  console.log(fb == xj); //true
  console.log(fb === xj); //true
  console.log(fb === fbyx); //false
  ```

- this

  this 指当前对象的引用，始终建议在代码内部使用 this 而不要使用对象名，不同对象的 this 只指向当前对象

  ```js
  let xj = {
    name: "小杰",
    show() {
      return this.name;
    }
  };
  let fb = xj;
  xj = null;
  console.log(fb.show()); // 小杰
  ```

- 展开语法

  使用 ... 可以展示对象的结构

  合并对象

  ```js
  let fb = { name: "风暴", web: "fengbaogame.com" };
  let info = { ...fb, site: "fbgame" };
  console.log(info);  // {name: "风暴", web: "fengbaogame.com", site: "fbgame"}
  ```

  函数参数合并

  ```js
  function upload(params) {
    let config = {
      type: "*.jpeg,*.png",
      size: 10000
    };
    params = { ...config, ...params };
    console.log(params);  // {type: "*.jpeg,*.png", size: 999}
  }
  upload({ size: 999 })
  ```

## 1.对象转换

- 基础知识

  对象直接参与计算时，系统会根据计算的场景在 string，number，default间转换

  - 如果声明需要字符串类型，调用顺序为 toString > valueOf

    ```js
    let fengbao = new Number(1);
    console.log(fengbao);   // Number {1}
    console.log(fengbao + "3"); // 13
    ```

  - 如果场景需要数值类型，调用顺序为 valueOf > toString

    ```js
    let fengbao = new Number(1);
    console.log(fengbao);   // Number {1}
    console.log(fengbao + 3); // 4
    ```

  - 声明不确定时使用 default，大部分对象的 default 会当数值使用

    ```js
    let fenbao = new Number(1);
    console.log(fenbao == "1"); //true
    ```

- Symbol.toPrimitive

  内部自定义 Symbol.toPrimitive 方法用来处理所有的转换场景

  ```js
  let fb = {
    num: 1,
    [Symbol.toPrimitive]: function() {
      return this.num;
    }
  };
  console.log(fb + 3); //4
  ```

- valueOf / toString

  可以自定义 valueOf 与 toString 方法用来转换，转换不限制返回类型

  ```js
  let fb = {
    name: "风暴",
    num: 1,
    valueOf: function() {
      console.log("valueOf");
      return this.num;
    },
    toString: function() {
      console.log("toString");
      return this.name;
    }
  };
  console.log(fb + 3); // valueOf 4
  console.log(`${fb}小杰`); // toString 风暴小杰
  ```

## 2.解构赋值

解构是一种更简洁的赋值特性，可以理解为分解一个数据的结构

- 基本使用

  ```js
  //对象使用
  let info = {name:'风暴游戏',url:'fengbaogame.com'};
  let {name:n,url:u} = info  // 右边赋值给左边
  console.log(n); // 风暴游戏
  
  //如果属性名与变量相同可以省略属性定义
  let {name,url} = {name:'风暴游戏',url:'fengbaogame.com'};
  console.log(name); // 风暴游戏
  ```

  函数返回值直接解构到变量

  ```js
  function fb() {
    return {
      name: '风暴',
      url: 'fengbaogame.com'
    };
  }
  let {name: n,url: u} = fb();
  console.log(n); // 风暴
  ```

  函数传参

  ```js
  function fb({ name, age }) {
    console.log(name, age); // 小杰 18
  }
  fb({ name: "小杰", age: 18 });
  ```

- 严格模式

  非严格模式可以不使用声明指令，严格模式下必须使用声明

  ```js
  // "use strict";
  ({name, url} = {name:'风暴游戏', url:'fengbaogame.com'});
  console.log(name, url); // 风暴游戏 fengbaogame.com
  ```

  建议使用 let 声明

  ```js
  "use strict";
  let {name, url} = {name:'风暴游戏', url:'fengbaogame.com'};
  console.log(name, url); // 风暴游戏 fengbaogame.com
  ```

- 简洁定义

  如果属性名与赋值的变量名相同可以更简洁

  ```js
  let web = { name: "风暴游戏",url: "fengbaogame.com" };
  let { name, url } = web;
  console.log(name); //风暴游戏
  ```

  只赋值部分变量

  ```js
  let [,url]=['风暴游戏','fengbaogame.com'];
  console.log(url);// fengbaogame.com
  
  let {name}= {name:'风暴游戏',url:'fengbaogame.com'};
  console.log(name); // 风暴游戏
  ```

  可以直接使用变量赋值给对象属性

  ```js
  let name = "风暴游戏",url = "fengbaogame.com";
  //标准写法如下
  let hd = { name: name, url: url };
  console.log(hd);  //{name: "风暴游戏", url: "fengbaogame.com"}
  
  //如果属性和值变量同名可以写成以下简写形式
  let opt = { name, url };
  console.log(opt); //{name: "风暴游戏", url: "fengbaogame.com"}
  ```

- 嵌套结构

  可以操作多层复杂数据结构

  ```js
  const fb = {
    name:'风暴游戏',
    lessons:{
      title:'JS'
    }
  }
  const {name,lessons:{title}}  = fb;
  console.log(name,title); //风暴游戏 JS
  ```

- 默认值

  为变量设置默认值

  ```js
  let [name, site = 'fbgame'] = ['风暴游戏'];
  console.log(site); // fbgame
  
  let {name1,url,user='小杰'}= {name1:'风暴游戏',url:'fengbaogame.com'};
  console.log(name,user); // 风暴游戏 小杰
  ```

  使用默认值特性可以方便的对参数预设

  ```js
  function createElement(options) {
    let {
      width = '200px',
      height = '100px',
      backgroundColor = 'red'
    } = options;
    
    const h2 = document.createElement('h2');
    h2.style.width = width;
    h2.style.height = height;
    h2.style.backgroundColor = backgroundColor;
    document.body.appendChild(h2);
  }
  createElement({
  	backgroundColor: 'green'
  });
  ```

- 函数参数

  数组参数的使用

  ```js
  function fb([a, b]) {
  	console.log(a, b);  // 风暴游戏 fbgame
  }
  fb(['风暴游戏', 'fbgame']);
  ```

  对象参数使用

  ```js
  function fb({name,url,user='小杰'}) {
  	console.log(name,url,user);
  }
  fb({name:'风暴游戏','url':'fengbaogame.com'}); //风暴游戏 houdunren.com 小杰
  ```

  对象解构传参

  ```js
  function user(name, { sex, age } = {}) {
    console.log(name, sex, age); //小杰 男 20
  }
  user("小杰", { sex: "男", age: 20 });
  ```

## 3.属性管理

- 添加属性

  可以为对象添加属性

  ```js
  let obj = {name: "风暴游戏"};
  obj.site = "fengbaogame.com";
  console.log(obj)
  ```
  
- 删除属性

  使用 delete 可以删除属性

  ```js
  let obj = { name: "风暴游戏" };
  delete obj.name;
  console.log(obj.name); //undefined;
  ```

- 检测属性

  hasOwnProperty 检测对象自身是否包含指定属性，不检测原型链上继承的属性

  ```js
  let obj = {name: "小杰"};
  console.log(obj.hasOwnProperty("name"));  // true
  ```

  通过数组查看

  ```js
  let arr = ['风暴游戏'];
  console.log(arr);   // ['风暴游戏']
  console.log(arr.hasOwnProperty("length"));  // true
  console.log(arr.hasOwnProperty('concat'));  // false
  console.log("concat" in arr);   // true
  ```

  使用in可以在原型对象上检测

  ```js
  let obj = {name: "风暴游戏"};
  let fb = {
    web: "fengbaogame.com"
  };
  
  //设置fb为obj的新原型
  Object.setPrototypeOf(obj, fb);
  console.log(obj); // {name: '风暴游戏'}
  
  console.log("web" in obj); // true
  console.log(obj.hasOwnProperty("web")); // false
  ```

- 获取属性名

  使用 Object.getOwnPropertyNames 可以获取对象的属性名集合

  ```js
  let fb = {name: '风暴游戏', year: 2020}
  const names = Object.getOwnPropertyNames(fb);
  console.log(names);  // ['name', 'year']
  ```

- assign

  可以使用 Object.assign 静态方法设置属性

  ```js
  let fb = {a: 1, b: '2'};
  fb = Object.assign(fb, {c: 4}, {d: "6"});
  console.log(fb);  // {a: 1, b: '2', c: 4, d: '6'}
  ```

- 计算属性

  对象属性可以通过表达式计算定义

  ```js
  let id = 0;
  const user = {
    [`id-${id++}`]: id,
    [`id-${id++}`]: id,
    [`id-${id++}`]: id
  };
  console.log(user);  // {id-0: 1, id-1: 2, id-2: 3}
  ```

  使用计算属性可以为文章定义键名

  ```js
  const lessons = [
    {
      title: "媒体查询响应式布局",
      category: "css"
    },
    {
      title: "FLEX 弹性盒模型",
      category: "css"
    },
    {
      title: "MYSQL多表查询随意操作",
      category: "mysql"
    }
  ];
  let lessonObj = lessons.reduce((obj, cur, index) => {
    obj[`${cur["category"]}-${index}`] = cur;
    return obj;
  }, {});
  console.log(lessonObj); // {css-0: {…}, css-1: {…}, mysql-2: {…}}
  console.log(lessonObj["css-0"]); // {title: "媒体查询响应式布局", category: "css"}
  ```

- 传值操作

  对象是引用类型赋值是传址操作

  ```js
  let user = {
  	name: '风暴游戏'
  };
  let fb = {
  	stu: user
  };
  fb.stu.name = 'fbgame';
  console.log(user.name); // fbgame
  ```

## 4.遍历对象

- 获取内容

  使用系统提供的 API 可以方便获取对象属性与值

  ```js
  const fb = {
    name: "风暴游戏",
    age: 10
  };
  console.log(Object.keys(fb)); // ["name", "age"]
  console.log(Object.values(fb)); // ["风暴游戏", 10]
  console.log(Object.entries(fb)); // [["name","风暴游戏"],["age",10]]
  ```

- for/in

  使用 for/in 遍历对象属性

  ```js
  const fb = {
    name: "风暴游戏",
    age: 10
  };
  for(let key in fb) {
    console.log(key); // name age
  }
  ```

- for/of 用于遍历迭代对象，不能直接操作对象，但 Object.keys 方法返回的是迭代对象

  ```js
  const fb = {
    name: "风暴游戏",
    age: 10
  };
  for(let key of Object.keys(fb)) {
    console.log(key); // name age
  }
  ```

  获取对象属性值

  ```js
  const fb = {
    name: "风暴游戏",
    age: 10
  };
  for(let key of Object.values(fb)) {
    console.log(key); // 风暴游戏 10
  }
  ```

  同时获取属性名与值

  ```js
  const fb = {
    name: "风暴游戏",
    age: 10
  };
  for(let key of Object.entries(fb)) {
    console.log(key); // ['name', '风暴游戏'] ['age', 10]
  }
  
  ```

  使用扩展语法同时获取属性名与值

  ```js
  const fb = {
    name: "风暴游戏",
    age: 10
  };
  for (const [key, value] of Object.entries(fb)) {
    console.log(key, value);  // ['name', '风暴游戏'] ['age', 10]
  }
  ```

  添加 Dom 元素

  ```js
  let lessons = [
    { name: "js", click: 23 },
    { name: "node", click: 192 }
  ];
  let ul = document.createElement("ul");
  for (const val of lessons) {
    let li = document.createElement("li");
    li.innerHTML = `课程:${val.name},点击数:${val.click}`;
    ul.appendChild(li);
  }
  document.body.appendChild(ul);
  ```

## 5.对象拷贝

对象赋值时复制的是内存地址，所以一个对象的改变直接影响另一个

```js
let obj = {
  name: '风暴游戏',
  user: {
  	name: 'fbgame'
  }
}
let a = obj;
let b = obj;
a.name = 'lisi';
console.log(b.name); //lisi
```

- 浅拷贝

  使用 for/in 执行对象拷贝

  ```js
  let obj = {name: "风暴游戏"};
  
  let fb = {};
  for (const key in obj) {
    fb[key] = obj[key];
  }
  
  fb.name = "fbgame";
  console.log(fb);  // {name: 'fbgame'}
  console.log(obj);   // {name: '风暴游戏'}
  ```

  Object.assign 函数可简单的实现浅拷贝，它是将两个对象的属性叠加，后面的对象属性会覆盖前面对象同名属性

  ```js
  let user = {
  	name: '风暴游戏'
  };
  let fb = {
  	stu: Object.assign({}, user)
  };
  fb.stu.name = 'fbgame';
  console.log(user.name); //风暴游戏
  ```

  使用展示语法也可以实现浅拷贝

  ```js
  let obj = {
    name: "风暴游戏"
  };
  let fb = { ...obj };
  fb.name = "fbgame";
  console.log(fb);  // {name: 'fbgame'}
  console.log(obj);   // {name: '风暴游戏'}
  ```

- 深拷贝

  完全的复制一个对象，两个对象是完全独立的

  ```js
  let obj = {
    name: "风暴游戏",
    user: {
      name: "fbgame"
    },
    data: []
  };
  
  function copy(object) {
    let obj = object instanceof Array ? [] : {};
    for (const [k, v] of Object.entries(object)) {
      obj[k] = typeof v == "object" ? copy(v) : v;
    }
    return obj;
  }
  
  let fb = copy(obj);
  fb.data.push("小杰");
  console.log(fb);  // {name: '风暴游戏', user: {…}, data: Array(1)}
  console.log(obj);  // {name: '风暴游戏', user: {…}, data: Array(0)}
  ```

## 6.构建函数

对象可以通过内置或自定义的构造函数创建

- 工厂函数

  在函数中返回对象的函数称为工厂函数

  - 减少重复创建相同类型对象的代码
  - 修改工厂函数的方法影响所有同类对象

  ```js
  function stu(name) {
    return {
      name,
      show() {
        console.log(this.name);
      }
    };
  }
  const lisi = stu("李四");
  lisi.show();  // 李四
  const xj = stu("小杰");
  xj.show();    // 小杰
  ```

- 构造函数

  构造函数用于创建对象，它的上下文为新的对象实例

  - 构造函数名首字母大写，即 Pascal 命名规范

  - this 指当前创建的对象

  - 不需要返回 this ，系统会自动完成

  - 需要使用 new 关键字生成对象

    ```js
    function Student(name) {
      this.name = name;
      this.show = function() {
        console.log(this.name);
      };
      // return this;
    }
    const lisi = new Student("李四");
    lisi.show();  // 李四
    const xj = new Student("小杰");
    xj.show();    // 小杰
    ```

    如果构造函数返回对象，实例化后的对象将是此函数

    ```js
    function ArrayObject(...values) {
      const arr = new Array();
      arr.push.apply(arr, values);
      arr.string = function(sym = "|") {
        return this.join(sym);
      };
      return arr;
    }
    const array = new ArrayObject(1, 2, 3);
    console.log(array);   // [1, 2, 3, string: ƒ]
    console.log(array.string("-"));   // 1-2-3
    ```

- 严格模式

  在严格模式下方法中的 this 值为 undefined，这是为了防止无意的修改 window 对象

  ```js
  "use strict"
  function User() {
    this.show = function() {
      console.log(this);
    };
  }
  let fb = new User();
  fb.show(); //User {show: ƒ}
  
  let xj = fb.show;
  xj(); //undefined
  ```

- 内置构造

  js 中大部分数据类型都是通过构造函数创建的

  ```js
  const num = new Number(99);
  console.log(num.valueOf());   // 99
  
  const string = new String("风暴游戏");
  console.log(string.valueOf());    // 风暴游戏
  
  const boolean = new Boolean(true);
  console.log(boolean.valueOf());   // true
  
  const date = new Date();
  console.log(date.valueOf() * 1);    // 1630639287701
  
  const regexp = new RegExp("\\d+");
  console.log(regexp.test(99));   // true
  
  let fb = new Object();
  fb.name = "风暴游戏";
  console.log(fb);    // {name: '风暴游戏'}
  ```

  字面量创建的对象，内部也是调用了 Object 构造函数

  ```js
  const fb = {
    name: "风暴游戏"
  };
  console.log(fb.constructor); //ƒ Object() { [native code] }
  
  //下面是使用构造函数创建对象
  const fbgame = new Object();
  fbgame.title = "开源内容管理系统";
  console.log(fbgame);    // {title: '开源内容管理系统'}
  ```

- 对象函数

  在 js 中函数也是一个对象

  函数是由系统内置的 Function 构造函数创建的

  ```js
  function fb(name) {}
  
  console.log(fb.toString());   // function fb(name) {}
  console.log(fb.length);   // 1
  console.log(fb.constructor);    // ƒ Function() { [native code] }
  ```

  使用内置构造函数创建的函数

  ```js
  const User = new Function(`name`,`
    this.name = name;
    this.show = function() {
      return this.name;
    };
  `
  );
  
  const lisi = new User("李四");
  console.log(lisi.show());    // 李四
  ```

## 7.抽象特性

将复杂的功能隐藏在内部，只开放给外部少量方法，更改对象内部的复杂逻辑不会对外部调用造成影响，即抽象

- 问题分析

  将对象属性封装到构造函数内部

  ```js
  function User(name, age) {
    this.name = name;
    this.age = age;
    this.info = function() {
      return this.age > 50 ? "中年人" : "年轻人";
    };
    this.about = function() {
      return `${this.name}是${this.info()}`;
    };
  }
  let lisi = new User("李四", 22);
  console.log(lisi.about());    // 李四是年轻人
  ```

- 抽象封装

  使用闭包特性将对象进行抽象处理

  ```js
  function User(name, age) {
    let data = { name, age };
    let info = function() {
      return data.age > 50 ? "中年人" : "年轻人";
    };
    this.message = function() {
      return `${data.name}是${info()}`;
    };
  }
  let lisi = new User("三炮", 22);
  console.log(lisi.message());    // 三炮是年轻人
  ```

## 8.属性特征

js 中可以对属性的访问特性进行控制

- 查看特征

  使用 Object.getOwnPropertyDescriptor 查看对象属性的描述

  ```js
  "use strict";
  const user = {
    name: "向军",
    age: 18
  };
  let desc = Object.getOwnPropertyDescriptor(user, "name");
  console.log(JSON.stringify(desc, null, 2));   /* {
    "value": "向军",
    "writable": true,
    "enumerable": true,
    "configurable": true
  } */
  ```

  使用  Object.getOwnPropertyDescriptors 查看对象所有属性的描述

  ```js
  "use strict";
  const user = {
    name: "向军",
    age: 18
  };
  let desc = Object.getOwnPropertyDescriptors(user);
  console.log(JSON.stringify(desc, null, 2));   /* {
    "name": {
      "value": "向军",
      "writable": true,
      "enumerable": true,
      "configurable": true
    },
    "age": {
      "value": 18,
      "writable": true,
      "enumerable": true,
      "configurable": true
    }
  } */
  ```

  属性包括以下四种特性

  |     特性     |                          说明                          |  默认值   |
  | :----------: | :----------------------------------------------------: | :-------: |
  | configurable | 能否使用delete、能否需改属性特性、或能否修改访问器属性 |   true    |
  |  enumerable  |   对象属性是否可通过for-in循环，或Object.keys() 读取   |   true    |
  |   writable   |                   对象属性是否可修改                   |   true    |
  |    value     |                    对象属性的默认值                    | undefined |

- 设置特征

  使用 Object.defineProperty 方法修改属性的特征

  通过下面的设置属性 name 将不能被遍历，删除，修改

  ```js
  "use strict";
  let user = {
    name: "小杰"
  };
  Object.defineProperty(user, "name", {
    value: "风暴游戏",
    writable: false,
    enumerable: false,
    configurable: false
  });
  console.log(user.name);		// 风暴游戏
  
  // 使用以下代码对上面的配置进行测试
  // 不允许修改
  user.name = "工作室"; // Error
  
  // 不能遍历
  console.log(Object.keys(user));  // []
  
  //不允许删除
  delete user.name;
  console.log(user);   // Error
  
  //不允许配置
   Object.defineProperty(user, "name", {
     value: "风暴游戏工作室",
     writable: true,
     enumerable: false,
     configurable: false 
   });    // Error
  ```

  使用 Object.defineProperties 可以一次设置多个属性

  ```js
  "use strict";
  let user = {};
  Object.defineProperties(user, {
    name: { value: "小杰", writable: false },
    age: { value: 18 }
  });
  console.log(user);    // {name: '小杰', age: 18}
  user.name = "风暴游戏"; // Error
  ```

- 禁止添加

  Object.preventExtensions 禁止向对象添加属性

  ```js
  "use strict";
  const user = {
    name: "小杰"
  };
  Object.preventExtensions(user);
  user.age = 18; // Error
  ```

  Object.isExtensible 判断是否能向对象中添加属性

  ```js
  "use strict";
  let user = {
    name: "小杰"
  }
  Object.preventExtensions(user);
  console.log(Object.isExtensible(user));   // false
  ```

- 封闭对象

  Object.seal() 方法封闭一个对象，阻止添加新属性并将所有属性标记为 configurable: false

  ```js
  "use strict";
  const user = {
    name: "风暴游戏",
    age: 18
  };
  
  Object.seal(user);
  console.log(
    JSON.stringify(Object.getOwnPropertyDescriptors(user), null, 2)   //
  );
  
  Object.seal(user);
  console.log(Object.isSealed(user));   // true
  delete user.name; // Error
  ```

  Object.isSealed 如果对象是密封的则返回 true ，属性都具有 configurable: false

  ```js
  "use strict";
  const user = {
    name: "小杰"
  };
  Object.seal(user);
  console.log(Object.isSealed(user)); // true
  ```

- 冻结对象

  Object.freeze 冻结对象后不允许添加、删除、修改属性，writable、configurable 都标记为 false

  ```js
  "use strict";
  const user = {
    name: "小杰"
  };
  Object.freeze(user);
  user.name = "风暴游戏工作室"; // Error
  </script>
  ```

  Object.isFrozen() 方法判断一个对象是否被冻结

  ```js
  "use strict";
  const user = {
    name: "向军"
  };
  Object.freeze(user);
  console.log(Object.isFrozen(user));   // true
  ```

## 9.属性访问器

getter 方法用于获得属性值，setter方法用于设置属性，这是 js 提供的存取器特性，即使用函数来管理属性

用于避免错误的赋值；需要动态监测值的改变；属性只能在访问器和普通属性任选其一，不能共同存在

- getter/setter

  使用访问器监听控制用户的年龄数据

  ```js
  "use strict";
  const user = {
    data: { name: '小杰', age: null },
    set age(value) {
      if (typeof value != "number" || value > 100 || value < 10) {
        throw new Error("年龄格式错误");
      }
      this.data.age = value;
    },
    get age() {
      return `年龄是: ${this.data.age}`;
    }
  };
  user.age = 99;
  console.log(user.age);    // 年龄是: 99
  ```

  使用 getter 把课程总价设置为只读

  ```js
  let Lesson = {
    lists: [
      { name: "js", price: 100 },
      { name: "mysql", price: 212 },
      { name: "vue.js", price: 98 }
    ],
    get total() {
      return this.lists.reduce((t, b) => t + b.price, 0);
    }
  };
  console.log(Lesson.total); // 410
  Lesson.total = 30; // Error
  ```

  通过设置网站名称与网址体验 getter/setter 批量设置属性的使用

  ```js
  const web = {
    name: "风暴游戏",
    url: "fengbaogame.com",
    get site() {
      return `${this.name} ${this.url}`;
    },
    set site(value) {
      [this.name, this.url] = value.split(",");
    }
  };
  web.site = "风暴游戏工作室,fbgame.com";
  console.log(web.site);  // 风暴游戏工作室 fbgame.com
  ```

  设置 token 储取

  ```js
  let Request = {
    get token() {
      let con = localStorage.getItem('token');
      if (!con) {
      	alert('请登录后获取token')
      } else {
      	return con;
      }
    },
    set token(con) {
    	localStorage.setItem('token', con);
    }
  };
  // Request.token = 'fengbao'
  console.log(Request.token);
  ```

  定义内部私有属性

  ```js
  "use strict";
  const user = {
    get name() {
      return this._name;
    },
    set name(value) {
      if (value.length <= 3) {
        throw new Error("用户名不能小于三位");
      }
      this._name = value;
    }
  };
  user.name = "风暴游戏工作室";
  console.log(user.name);   // 风暴游戏工作室
  ```

- 访问器描述符

  使用 defineProperty 可以模拟定义私有属性，从而使用面向对象的特性

  ```js
  function User(name, age) {
    let data = { name, age };
    Object.defineProperties(this, {
      name: {
        get() {
          return data.name;
        },
        set(value) {
          if (value.trim() == "") throw new Error("无效的用户名");
          data.name = value;
        }
      },
      age: {
        get() {
          return data.name;
        },
        set(value) {
          if (value.trim() == "") throw new Error("无效的用户名");
          data.name = value;
        }
      }
    });
  }
  let fb = new User("小杰1", 20);
  console.log(fb.name);   // 小杰1
  fb.name = "小杰";   // 小杰
  console.log(fb.name);
  ```

  也可以使用语法糖 class 定义

  ```js
  "use strict";
  const DATA = Symbol();
  class User {
    constructor(name, age) {
      this[DATA] = { name, age };
    }
    get name() {
      return this[DATA].name;
    }
    set name(value) {
      if (value.trim() == "") throw new Error("无效的用户名");
      this[DATA].name = value;
    }
    get age() {
      return this[DATA].name;
    }
    set age(value) {
      if (value.trim() == "") throw new Error("无效的用户名");
      this[DATA].name = value;
    }
  }
  let fb = new User("风暴游戏", 1);
  console.log(fb.name);   // 风暴游戏
  fb.name = "小杰";   
  console.log(fb.name);   // 小杰
  console.log(fb);    // User {Symbol(): {…}}
  ```

- 闭包访问器

  结合闭包特性对属性进行访问控制

  ```js
  // 访问器定义在函数中，并接收参数
  // 在 get() 中通过闭包返回 v
  // 在 set() 中修改了 v,这会影响 get() 访问的闭包数据 v
  let data = {
    name: 'fengbaogame.com',
  }
  for (const [key, value] of Object.entries(data)) {
    observer(data, key, value)
  }
  
  function observer(data, key, v) {
    Object.defineProperty(data, key, {
      get() {
        return v
      },
      set(newValue) {
        v = newValue
      },
    })
  }
  data.name = '风暴游戏'
  console.dir(data.name) // 风暴游戏
  ```

## 10.代理拦截

代理（拦截器）是对象访问的控制，setter/getter 是对单个对象属性的控制，而代理是对整个对象的控制

读写属性是代码更简洁；对象的多个属性控制统一交给代理完成；严格模式下 set 必须返回布尔值

- 使用方法

  ```js
  "use strict";
  const fb = { name: "风暴游戏" };
  const proxy = new Proxy(fb, {
    get(obj, property) {
      return obj[property];
    },
    set(obj, property, value) {
      obj[property] = value;
      return true;
    }
  });
  proxy.age = 10;
  console.log(fb);    // {name: '风暴游戏', age: 10}
  ```

- 代理函数

  如果代理以函数方式执行，会执行代理中定义 apply 方法

  - 参数说明：函数，上下文对象，参数

  使用 apply 计算函数执行时间

  ```js
  function factorial(num) {
    return num == 1 ? 1 : num * factorial(num - 1);
  }
  let proxy = new Proxy(factorial, {
    apply(func, obj, args) {
      console.time("run");
      func.apply(obj, args);
      console.timeEnd("run");
    }
  });
  proxy.apply(this, [1, 2, 3]);
  ```

- 截取字符

  对数组进行代理，用于截取标题操作

  ```js
  const stringDot = {
    get(target, key) {
      const title = target[key].title;
      const len = 5;
      return title.length > len
        ? title.substr(0, len) + ".".repeat(3)
        : title;
    }
  };
  const lessons = [
    {
      title: "媒体查询响应式布局",
      category: "css"
    },
    {
      title: "FLEX 弹性盒模型",
      category: "css"
    },
    {
      title: "MYSQL多表查询随意操作",
      category: "mysql"
    }
  ];
  const stringDotProxy = new Proxy(lessons, stringDot);
  console.log(stringDotProxy[0]);
  ```

- 双向绑定

  通过代理实现 vue 等前端框架的数据绑定特性

  ```js
  <body>
  <input type="text" v-model="title" />
  <input type="text" v-model="title" />
  <div v-bind="title"></div>
  </body>
  <script>
  function View() {
  	//设置代理拦截
    let proxy = new Proxy(
      {},
      {
        get(obj, property) {},
        set(obj, property, value) {
          obj[property] = value;
          document
            .querySelectorAll(
              `[v-model="${property}"],[v-bind="${property}"]`
            )
            .forEach(el => {
              el.innerHTML = value;
              el.value = value;
            });
        }
      }
    );
    //初始化绑定元素事件
    this.run = function() {
      const els = document.querySelectorAll("[v-model]");
      els.forEach(item => {
        item.addEventListener("keyup", function() {
          proxy[this.getAttribute("v-model")] = this.value;
        });
      });
    };
  }
  let view = new View().run();
  </script>
  ```

- 表单验证

  ```js
   <style>
    body {
      padding: 50px;
      background: #34495e;
    }
    input {
      border: solid 10px #ddd;
      height: 30px;
    }
    .error {
      border: solid 10px red;
    }
  </style>
  <body>
    <input type="text" validate rule="max:12,min:3" />
    <input type="text" validate rule="max:3,isNumber" />
  </body>
  <script>
    "use strict";
    //验证处理类
    class Validate {
      max(value, len) {
        return value.length <= len;
      }
      min(value, len) {
        return value.length >= len;
      }
      isNumber(value) {
        return /^\d+$/.test(value);
      }
    }
  
    //代理工厂
    function makeProxy(target) {
      return new Proxy(target, {
        get(target, key) {
          return target[key];
        },
        set(target, key, el) {
          const rule = el.getAttribute("rule");
          const validate = new Validate();
          let state = rule.split(",").every(rule => {
            const info = rule.split(":");
            return validate[info[0]](el.value, info[1]);
          });
          el.classList[state ? "remove":"add"]("error");
          return true;
        }
      });
    }
  
    const nodes = makeProxy(document.querySelectorAll("[validate]"));
    nodes.forEach((item, i) => {
      item.addEventListener("keyup", function() {
        nodes[i] = this;
      });
    });
  </script>
  ```

  

## 11.JSON

json 是一种轻量级的数据交换格式，易与人阅读和编写；使用 json 数据格式是替换 xml 的最佳方式，主流语言都很好的支持 json 格式，所以 json 也是前后台传输数据的主要格式；json 标准中要求使用双引号包裹属性，虽然有些语言不强制，但使用双引号可避免多程序间传输发生错误

- 声明定义

  基本结构

  ```js
  let fb = {
    "title": "风暴游戏",
    "url": "fengbaogame.com",
    "teacher": {
    	"name": "小杰",
    }
  }
  console.log(fb.teacher.name);
  ```

  数组结构

  ```js
  let lessons = [
    {
      "title": '媒体查询响应式布局',
      "category": 'css',
      "click": 199
    },
    {
      "title": 'FLEX 弹性盒模型',
      "category": 'css',
      "click": 12
    },
    {
      "title": 'MYSQL多表查询随意操作',
      "category": 'mysql',
      "click": 89
    }
  ];
  
  console.log(lessons[0].title);
  ```

- 序列化

  序列化是将 json 转换为字符串，一般用来向其他语言传输使用

  ```js
  let fb = {
    "title": "风暴游戏",
    "url": "fengbaogame.com",
    "teacher": {
    	"name": "小杰",
    }
  }
  console.log(JSON.stringify(fb));  // {"title":"风暴游戏","url":"fengbaogame.com","teacher":{"name":"小杰"}}
  ```

  根据第二个参数指定保存的属性

  ```js
  let fb = {
    "title": "风暴游戏",
    "url": "fengbaogame.com",
    "teacher": {
    	"name": "小杰",
    }
  }
  console.log(JSON.stringify(fb, ['title', 'url']));  // {"title":"风暴游戏","url":"fengbaogame.com"}
  ```

  第三个参数是用来控制 Tab 数量，如果是字符串则为前导字符串

  ```js
  let fb = {
    "title": "风暴游戏",
    "url": "fengbaogame.com",
    "teacher": {
    	"name": "小杰",
    }
  }
  console.log(JSON.stringify(fb, null, 2)); /* {
    "title": "风暴游戏",
    "url": "fengbaogame.com",
    "teacher": {
      "name": "小杰"
    }
  } */
  console.log(JSON.stringify(fb, null, "--"));  /* {
  --"title": "风暴游戏",
  --"url": "fengbaogame.com",
  --"teacher": {
  ----"name": "小杰"
  --}
  } */
  ```

  为数据添加 toJSON 方法来定义返回格式

  ```js
  let fb = {
      "title": "风暴游戏",
      "url": "fengbaogame.com",
      "teacher": {
          "name": "小杰",
      },
      "toJSON": function () {
          return {
              "url": this.url,
              "name": this.teacher.name
          };
      }
  }
  console.log(JSON.stringify(fb));  // {"title":"fengbaogame.com","name":"小杰"}
  ```

- 反序列化

  使用 JSON.parse 将字符串 json 解析成对象

  ```js
  let fb = {
    "title": "后盾人",
    "url": "fengbaogame.com",
    "teacher": {
    	"name": "小杰",
    }
  }
  let jsonStr = JSON.stringify(fb);
  console.log(JSON.parse(jsonStr));   // {title: '后盾人', url: 'fengbaogame.com', teacher: {…}}
  ```

  使用第二个参数函数来对返回的数据二次处理

  ```js
  let fb = {
    title: "风暴游戏",
    url: "fengbaogame.com",
    teacher: {
      name: "小杰"
    }
  };
  let jsonStr = JSON.stringify(fb);
  console.log(
    JSON.parse(jsonStr, (key, value) => {
      if (key == "title") {
        return `[推荐] ${value}`;
      }
      return value;
    })
  );  // {title: '[推荐] 风暴游戏', url: 'fengbaogame.com', teacher: {…}}
  ```

## 12.Reflect

reflect 是一个内置的对象，它提供拦截 js 操作的方法

reflect 并非一个构造函数，所以不能通过 new 运算符对其进行调用

# 10.原型与继承

## 0.原型基础

- 原型对象

  每一个对象都有一个原型 prototype 对象，通过函数创建的对象也将拥有这个原型对象，原型对象是一个指向对象的指针

  - 可以将原型理解为对象的父亲，对象从原型对象继承属性
  - 原型对象就是除了是某个对象的父母外没有什么特别之处
  - 所有函数的原型默认是 Object 的实例，这就是可以使用 toString/toValues/isPrototypeOf 等方法的原因
  - 使用原型对象为多个对象共享属性或方法
  - 如果对象本身不存在属性或方法，将到原型上查找
  - 使用原型可以解决通过构建函数创建对象时复制多个函数造成的内存占用问题
  - 原型包含 constructor 属性，指向构造函数
  - 对象包含 \_proto\_ 指向它的原型对象 

  使用数组原型对象的 concat 方法完成连接操作

  ```js
  let fb = ["a"];
  console.log(fb.concat("b"));  // ['a', 'b']
  console.log(fb);  // ['a']
  ```

  默认情况下创建的对象都有原型

  ![](https://i.loli.net/2021/09/21/1WOMdFkf7uACBtj.png)

  ```js
  let fb = { name: "风暴游戏" };
  console.log(fb);  // {name: '风暴游戏'}
  ```

  ```js
  // 以下 x，y 的原型都为元对象 Object ，即 js 中的根对象
  let x = {};
  let y = {};
  console.log(Object.getPrototypeOf(x) == Object.getPrototypeOf(y)); //true
  ```

  也可以创建一个极简对象(纯数据字典对象)，没有原型(原型为null)

  ![image-20210904212206006](https://i.loli.net/2021/09/21/RwzoLfxlkupEFbT.png)

  ```js
  let xj = Object.create(null, {
    name: {
      value: "小杰"
    }
  });
  console.log(xj.hasOwnProperty("name")); // Error
  
  //Object.keys是静态方法，不是原型方法所以是可以使用的
  console.log(Object.keys(xj)); // []
  ```

  函数拥有多个原型，prototype 用于实例对象使用，_ proto_ 用于函数对象使用

  ```js
  function User() {}
  User.__proto__.view = function() {
    console.log("User function view method");   // User function view method
  };
  User.view();
  
  User.prototype.show = function() {
    console.log("风暴游戏");  // 风暴游戏
  };
  let fb = new User();
  fb.show();
  console.log(User.prototype == fb.__proto__);  // true
  ```

  原型关系分析与方法继承的实例

  ![image-20191208003927158](https://i.loli.net/2021/09/21/iMVRe7kNIYyWU92.png)

  ```js
  let fb = new Object();
  fb.name = "风暴游戏";
  Object.prototype.show = function() {
    console.log("fengbaogame.com");
  };
  fb.show();  // fengbaogame.com
  console.log(fb.name);   // 风暴游戏
  
  function User() {}
  let xj = new User();
  xj.show();  // fengbaogame.com
  User.show();  // fengbaogame.com
  ```

  使用构造函数创建对象的原型体现

  - 构造函数拥有原型

  - 创建对象时构造函数把原型赋予对象

    ![image-20191010023843179](https://i.loli.net/2021/09/21/tvTopKJyb3e7PSd.png)

  ```js
  function User() {}
  let xj = new User();
  console.log(xj.__proto__ == User.prototype);  // true
  ```

  使用数组会产生多级继承，即原型链

  ![image-20191120174145258](https://i.loli.net/2021/09/21/TF3YdOHlrfvSRIo.png)

  ```js
  let fb = [];
  console.log(fb);  // []
  console.log(fb.__proto__ == Array.prototype);   // true
  
  let str = "";
  console.log(str.__proto__ == String.prototype);   // true
  ```

  使用 setPrototypeOf 与 getPrototypeOf 获取与设置原型

  ```js
  let fb = {};
  let parent = { name: "parent" };
  Object.setPrototypeOf(fb, parent);
  console.log(fb);  // {}
  console.log(Object.getPrototypeOf(fb));   // {name: 'parent'}
  ```

  使用自定义构造函数创建的对象的原型的体现

  ![image-20191120174956195](https://i.loli.net/2021/09/21/D5saL6k9MlKczHy.png)

  ```js
  function User() {}
  let fb = new User();
  console.log(fb);  // User {}
  ```

  constructor 存在于 prototype 原型中，用于指向构建函数的引用

  ```js
  function fb() {
    this.show = function() {
      return "show method";
    };
  }
  const obj = new fb(); 
  console.log(obj instanceof fb);   // true
  
  const obj2 = new obj.constructor();
  console.dir(obj2.show()); // show method
  ```

  使用对象的 constructor 创建对象

  ```js
  function User(name, age) {
    this.name = name;
    this.age = age;
  }
  
  function createByObject(obj, ...args) {
    const constructor = Object.getPrototypeOf(obj).constructor;
    return new constructor(...args);
  }
  
  let fb = new User("风暴游戏");
  let xj = createByObject(fb, "小杰", 20);
  console.log(xj);    // User {name: '小杰', age: 20}
  ```

- 原型链

  通过引用类型的原型，继承另一个引用类型的属性与方法，这就是实现继承的步骤

  ![image-20191010012103033](https://i.loli.net/2021/09/21/gmYGZbrz6neMxkw.png)

  使用 Object.setPrototypeOf 可设置对象的原型；Object.getPrototypeOf 用于获取一个对象的原型

  ```js
  // 继承关系 obj > fb > xj
  let obj = {
    name: "后盾人"
  };
  let fb = {
    web: "fengbaogame.com"
  };
  let xj = {
    soft: "fbgame"
  };
  //让obj继承fb，即设置obj的原型为fb
  Object.setPrototypeOf(obj, fb);
  Object.setPrototypeOf(fb, xj);
  console.log(obj.web);   // fengbaogame.com
  console.log(Object.getPrototypeOf(fb) == xj);  // true
  ```

- 原型检测

  instanceof 检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上

  ```js
  function A() {}
  function B() {}
  function C() {}
  
  const c = new C();
  B.prototype = c;
  const b = new B();
  A.prototype = b;
  const a = new A();
  
  console.dir(a instanceof A); //true
  console.dir(a instanceof B); //true
  console.dir(a instanceof C); //true
  console.dir(b instanceof C); //true
  console.dir(c instanceof B); //false
  ```

  使用 isPrototypeOf 检测一个对象是否是另一个对象的原型链中

  ```js
  const a = {};
  const b = {};
  const c = {};
  
  Object.setPrototypeOf(a, b);
  Object.setPrototypeOf(b, c);
  
  console.log(b.isPrototypeOf(a)); //true
  console.log(c.isPrototypeOf(a)); //true
  console.log(c.isPrototypeOf(b)); //true
  ```

- 属性遍历

  使用 in 检测原型链上是否存在属性，使用 hasOwnProperty 检测当前对象

  ```js
  let a = { url: "houdunren" };
  let b = { name: "后盾人" };
  Object.setPrototypeOf(a, b);
  console.log("name" in a);   // true
  console.log(a.hasOwnProperty("name"));    // false
  console.log(a.hasOwnProperty("url"));   // true
  ```

  使用 for/in 遍历时会遍历原型上的属性

  ```js
  let fb = { name: "风暴游戏" };
  let xj = Object.create(fb, {
    url: {
      value: "fengbaogame.com",
      enumerable: true
    }
  });
  for (const key in xj) {
    console.log(key);   // url name
  }
  ```

  hasOwnProperty 方法判断对象是否存在属性，而不会查找原型

  ```js
  let fb = { name: "风暴游戏" };
  let xj = Object.create(fb, {
    url: {
      value: "fengbaogame.com",
      enumerable: true
    }
  });
  for (const key in xj) {
    if (xj.hasOwnProperty(key)) {
      console.log(key);   // url
    }
  }
  ```

- 借用原型

  使用 call 或 apply 可以借用其他原型方法完成功能

  ```js
  // 下面的 xj 对象不能使用 max 方法，但可以借用 fb 对象的原型方法
  let fb = {
    data: [1, 2, 3, 4, 5]
  };
  Object.setPrototypeOf(fb, {
    max: function() {
      return this.data.sort((a, b) => b - a)[0];
    }
  });
  console.log(fb.max());    // 5
  
  let xj = {
    lessons: { js: 100, php: 78, node: 78, linux: 125 },
    get data() {
      return Object.values(this.lessons);
    }
  };
  console.log(fb.__proto__.max.apply(xj));    // 125
  ```

  ```js
  // 上例如果方法可以传参，那就可以不再 xj 对象中定义 getter 方法了
  let fb = {
    data: [1, 2, 3, 4, 5]
  };
  Object.setPrototypeOf(fb, {
    max: function(data) {
      return data.sort((a, b) => b - a)[0];
    }
  });
  console.log(fb.max(fb.data));   // 5
  
  let xj = {
    lessons: { js: 100, php: 78, node: 78, linux: 125 }
  };
  console.log(fb.__proto__.max.call(xj, Object.values(xj.lessons)));    // 125
  ```

  ```js
  // 因为 Math.max 就是获取最大值的方法，所以代码可以再次优化
  let fb = {
    data: [1, 2, 3, 4, 5]
  };
  console.log(Math.max.apply(null, Object.values(fb.data)));  // 5
  
  let xj = {
    lessons: { js: 100, php: 78, node: 78, linux: 125 }
  };
  console.log(Math.max.apply(xj, Object.values(xj.lessons))); // 125
  ```

  下面是获取设置了 `class` 属性的按钮，但DOM节点不能直接使用数组的`filter` 等方法，但借用数组的原型方法就可以操作了

  ```js
  <body>
    <button message="风暴游戏" class="red">风暴游戏</button>
    <button message="fbgame">hdcms</button>
  </body>
  <script>
    let btns = document.querySelectorAll("button");
    btns = Array.prototype.filter.call(btns, item => {
      return item.hasAttribute("class");
    });
  </script>
  ```

- this

  this 不受原型继承影响，this 指向调用属性时使用的对象

  ```js
  let fb = {
    name: "风暴游戏"
  };
  let fengbao = {
    name: "小杰",
    show() {
      return this.name;
    }
  };
  fb.__proto__ = fengbao;
  console.log(fb.show()); // 风暴游戏
  ```


## 1.原型总结

- prototype

  函数也是对象也有原型，函数有 `prototype` 属性指向他的原型

  为构造函数设置的原型，指当使用构造函数创建对象时把这个原型赋予给这个对象

  ```js
  function User(name) {
    this.name = name;
  }
  User.prototype = {
    show() {
      return this.name;
    }
  };
  let xj = new User("小杰");
  console.log(xj.show());   // 小杰
  ```

  函数默认`prototype` 指包含一个属性 `constructor` 的对象，`constructor` 指向当前构造函数

  ```js
  function User(name) {
    this.name = name;
  }
  let xj = new User("小杰");
  console.log(xj);    // User {name: '小杰'}
  console.log(User.prototype.constructor == User); //true
  console.log(xj.__proto__ == User.prototype); //true
  
  let lisi = new xj.constructor("李四");
  console.log(lisi.__proto__ == xj.__proto__); //true
  ```

  原型中保存引用类型会造成对象共享属性，所以一般只会在原型中定义方法。

  ```js
  function User() {}
  User.prototype = {
    lessons: ["JS", "VUE"]
  };
  const lisi = new User();
  const wangwu = new User();
  
  lisi.lessons.push("CSS");
  
  console.log(lisi.lessons); //["JS", "VUE", "CSS"]
  console.log(wangwu.lessons); //["JS", "VUE", "CSS"]
  ```

  为Object原型对象添加方法，将影响所有函数

  ```js
  <body>
    <button onclick="this.hide()">风暴游戏</button>
  </body>
  <script>
    Object.prototype.hide = function() {
      this.style.display = "none";
    };
  </script>
  ```

  了解了原型后可以为系统对象添加方法，比如为字符串添加了一截断函数

  - 不能将系统对象的原型直接赋值

    ```js
    String.prototype.truncate = function (len = 5) {
    	return this.length <= len ? this : this.substr(0, len) + '...';
    }
    console.log('风暴游戏工作室'.truncate(3)); // 风暴游...
    ```

- Object.create

  使用`Object.create`创建一个新对象时使用现有对象做为新对象的原型对象

  ![image-20210904215752027](https://i.loli.net/2021/09/21/vjFQnaBhXLyqHOD.png)

  使用 Object.create 设置对象原型

  ```js
  let user = {
    show() {
      return this.name;
    }
  };
  
  let fb = Object.create(user);
  fb.name = "小杰";
  console.log(fb.show());   // 小杰
  ```

  可以在设置时使用第二个参数设置新对象的属性

  ```js
  let user = {
    show() {
      return this.name;
    }
  };
  let fb = Object.create(user, {
    name: {
      value: "小杰"
    }
  });
  console.log(fb.show());    // 小杰
  console.log(fb);    // {name: '小杰'}
  ```

- \_\_proto\_\_

  在实例化对象上存在 \_\_proto\_\_记录了原型，所以可以通过对象访问到原型的属性或方法

  -  \_\_proto\_\_不是对象属性，理解为`prototype` 的 `getter/setter` 实现，他是一个非标准定义
  -  \_\_proto\_\_内部使用`getter/setter` 控制值，所以只允许对象或null
  - 建议使用 `Object.setPrototypeOf` 与`Object.getProttoeypOf` 替代\_\_proto\_\_

  ```js
  // 下面修改对象的 __proto__ 是不会成功的，因为__proto__ 内部使用getter/setter 控制值，所以只允许对象或null
  let xj = {};
  xj.__proto__ = "小杰";
  console.log(xj);    // {}
  ```

  ```js
  // 下面定义的__proto__ 就会成功，因为这是一个极简对象，没有原型对象所以不会影响__proto__赋值
  let fb = Object.create(null);
  fb.__proto__ = "小杰";
  console.log(fb);    // {__proto__: '小杰'}
  ```

  通过改变对象的 `__proto__` 原型对象来实现继承，继承可以实现多层

  ![image-20210904221811861](https://i.loli.net/2021/09/21/tsVNiHvFGX5gZ9h.png)

  ```js
  let fb = {
    name: "风暴游戏"
  };
  let fengbaogame = {
    show() {
      return this.name;
    }
  };
  let xj = {
    handle() {
      return `用户: ${this.name}`;
    }
  };
  fengbaogame.__proto__ = xj;
  fb.__proto__ = fengbaogame;
  console.log(fb.show());   // 风暴游戏
  console.log(fb.handle());   // 用户: 风暴游戏
  console.log(fb);    // {name: '风暴游戏'}
  ```

  构造函数中的\_\_proto\_\_使用

  ```js
  function User(name, age) {
    this.name = name;
    this.age = age;
  }
  User.prototype.show = function () {
  	return `姓名:${this.name}，年龄:${this.age}`;
  };
  let lisi = new User('李四', 12);
  let xiaoming = new User('小明', 32);
  console.log(lisi.__proto__ == User.prototype); //true
  ```

  可以使用 \_\_proto\_\_`bject.setPrototypeOf` 设置对象的原型，使用`Object.getProttoeypOf` 获取对象原型

  ```js
  function Person() {
    this.getName = function() {
      return this.name;
    };
  }
  function User(name, age) {
    this.name = name;
    this.age = age;
  }
  let lisi = new User("李四", 12);
  Object.setPrototypeOf(lisi, new Person());
  console.log(lisi.getName()); //李四
  ```

  对象设置属性，只是修改对象属性并不会修改原型属性，使用`hasOwnProperty` 判断对象本身是否含有属性并不会检测原型

  ```js
  function User() {}
  const lisi = new User();
  const wangwu = new User();
  
  lisi.name = "小明";
  console.log(lisi.name);   // 小明
  console.log(lisi.hasOwnProperty("name"));   // true
  
  //修改原型属性后
  lisi.__proto__.name = "张三";
  console.log(wangwu.name);   // 张三
  
  //删除对象属性后
  delete lisi.name;
  console.log(lisi.hasOwnProperty("name"));   // false
  console.log(lisi.name);   // 张三
  ```

  使用 `in` 会检测原型与对象，而 `hasOwnProperty` 只检测对象，所以结合后可判断属性是否在原型中

  ```js
  function User() {
  }
  User.prototype.name = "风暴游戏";
  const lisi = new User();
  //in会在原型中检测
  console.log("name" in lisi);    // true
  //hasOwnProperty 检测对象属性
  console.log(lisi.hasOwnProperty("name"));   // false
  ```

- 使用建议

  可以使用多种方式设置原型

  - `prototype` 构造函数的原型属性
  - `Object.create` 创建对象时指定原型
  - \_\_proto\_\_声明自定义的非标准属性设置原型，解决之前通过 `Object.create` 定义原型，而没提供获取方法
  - `Object.setPrototypeOf` 设置对象原型

  这几种方式都可以管理原型，一般情况来讲，使用 `prototype` 更改构造函数原型，使用 `Object.setPrototypeOf` 与 `Object.getPrototypeOf` 获取或设置原型

## 2.构造函数

- 原型属性

  构造函数在被`new` 时把构造函数的原型（prototype）赋值给新对象。如果对象中存在属性将使用对象属性，不再原型上查找方法

  构造函数只会产生一个原型对象

  ```js
  function fb() {
    this.show = function() {
      return "show in object";
    };
  }
  fb.prototype.show = function() {
    return "show in protitype";
  };
  const obj = new fb();
  console.log(obj.show());    // show in object
  ```

  对象的原型引用构造函数的原型对象，是在创建对象时确定的，当构造函数原型对象改变时会影响后面的实例对象

  ```js
  function fb() {}
  fb.prototype.name = "小杰";
  const obj1 = new fb();
  console.log(obj1.name);   // 小杰
  
  fb.prototype = {
    name: "风暴游戏"
  };
  const obj2 = new fb();
  console.log(obj2.name);     // 风暴游戏
  ```

- constructor

  构造函数的原型中包含属性 `constructor` 指向该构造函数

  ```js
  function User(name) {
    this.name = name;
  }
  let fb = new User('小杰');
  let zs = new fb.constructor('张三');
  console.log(zs);    // User {name: '张三'}
  ```

  直接设置了构造函数的原型将造成 `constructor` 丢失

  ```js
  function User(name) {
    this.name = name;
  }
  User.prototype = {
    show: function() {}
  };
  
  let fb = new User('张三');
  console.log(fb);   // User {name: '张三'}
  let xj = new fb.constructor('小杰');
  console.log(xj);    // String {'小杰'}
  ```

  正确的做法是要保证原型中的 `constructor`指向构造函数

  ```js
  function User(name) {
    this.name = name;
  }
  User.prototype = {
    constructor: User,
    show: function() {}
  }
  
  let fb = new User("小杰");
  console.log(fb);    // User {name: '小杰'}
  let xj = new fb.constructor("风暴");
  console.log(xj);    // User {name: '风暴'}
  ```

- 使用优化

  使用构造函数会产生函数复制造成内存占用，及函数不能共享的问题

  ```js
  function User(name) {
    this.naem = name;
    this.get = function() {
      return this.name;
    };
  }
  let xj = new User("小杰");
  let zs = new User("张三");
  console.log(xj.get == zs.get);    // false
  ```

  通过原型定义方法不会产生函数复制

  ```js
  function User(name) {
    this.name = name;
  }
  User.prototype.get = function() {
    return "风暴" + this.name;
  }
  let xj = new User("小杰");
  console.log(xj);    // User {name: '小杰'}
  console.log(xj.get());    // 风暴小杰
  
  let zs = new User("张三");
  console.log(zs);  // User {name: '张三'}
  console.log(zs.get());    // 风暴张三
  console.log(xj.get == zs.get);    // true
  
  // 通过修改原型方法会影响所有对象调用，因为方法是共用的
  xj.__proto__.get = function() {
    return "风暴游戏" + this.name;
  };
  console.log(xj.get());    // 风暴游戏小杰
  console.log(zs.get());    // 风暴游戏张三
  ```

  使用原型为多个实例共享属性

  ```js
  function User(name, age) {
    this.name = name;
    this.age = age;
    this.show = () => `你在${this.site}的姓名是：${this.name}，年龄是：${this.age}`
  }
  User.prototype.site = '风暴游戏';
  let xj = new User("小杰", 22);
  let zs = new User("张三", 20);
  
  console.log(xj.show()); // 你在风暴游戏的姓名是：小杰，年龄是：22
  console.log(zs.show()); // 你在风暴游戏的姓名是：张三，年龄是：20
  ```

  使用`Object.assign`一次设置原型方法来复用

  ```js
  function User(name, age) {
    this.name = name;
    this.age = age;
  }
  Object.assign(User.prototype, {
    getName() {
      return this.name;
    },
    getAge() {
      return this.age;
    }
  });
  let xj = new User("小杰", 22);
  let zs = new User("张三", 20);
  
  console.log(xj.getName());  // 小杰
  console.log(zs.getAge());   // 20
  console.log(zs.__proto__);    // ObjectgetAge: ƒ getAge() ƒ getName() constructor: ƒ User(name, age) [[Prototype]]: Object
  ```

- 体验继承

  下面为 `Stu` 更改了原型为`User` 的实例对象，`xj`是通过构造函数`xj`创建的实例对象

  - `xj`在执行`getName` 方法时会从自身并向上查找原型，这就是原型链特性
  - 当然如果把 `getName` 添加到对象上，就不继续追溯原型链了

  ```js
  function User() {}
  User.prototype.getName = function(name) {
    return this.name;
  }
  function Stu(name) {
    this.name = name;
  }
  
  Stu.prototype = new User();
  
  const xj = new Stu("小杰");
  console.log(xj.__proto__);    // User {}
  console.log(xj.getName());    // 小杰
  ```

## 3.继承与多态

当对象中没使用的属性时，JS会从原型上获取这就是继承在JavaScript中的实现

- 继承实现

  使用`Object.create` 创建对象，做为`Admin、Member`的原型对象来实现继承

  ![image-20191120214826701](https://i.loli.net/2021/09/21/znxvQjTKsd1uEVU.png)

  ```js
  function User() {}
  User.prototype.getUserName = function() {};
  
  function Admin() {}
  Admin.prototype = Object.create(User.prototype);
  Admin.prototype.role = function() {};
  
  function Member() {}
  Member.prototype = Object.create(User.prototype);
  Member.prototype.email = function() {};
  console.log(new Admin());   // Admin {}
  console.log(new Member());    // Member {}
  ```

  不能使用以下方式操作，因为这样会改变User的原型方法，这不是继承，这是改变原型

  ```js
  function User() {}
  User.prototype.getNmae = function() {};
  
  function Admin() {}
  Admin.prototype = User.prototype;
  Admin.prototype.role = function() {};
  let xj = new User();
  console.log(xj.getNmae());  // undefined 
  ```

- 构造函数

  有多种方式通过构造函数创建对象

  ```js
  function Admin() {}
  console.log((Admin === Admin.prototype.constructor));    // true
  
  let xj = new Admin.prototype.constructor();
  console.log(xj);    // Admin {}
  
  let zs = new Admin();
  console.log(zs);    // Admin {}
  ```

  因为有时根据得到的对象获取构造函数，然后再创建新对象所以需要保证构造函数存在，但如果直接设置了`Admin.prototype` 属性会造成`constructor`丢失，所以需要再次设置`constructor`值

  ```js
  function User() {}
  function Admin() {}
  
  Admin.prototype = Object.create(User.prototype);
  Admin.prototype.role = function() {};
  
  let xj = new Admin();
  // constructor丢失，返回User构造函数
  console.log(xj.constructor);  // User() {}
  
  Admin.prototype.constructor = Admin;
  
  let zs = new Admin();
  // 正确返回Admin构造函数
  console.log(zs.constructor);  // Admin() {}
  
  // 现在可以通过对象获取构造函数来创建新对象了
  console.log(new zs.constructor());  // Admin {}
  ```

  使用`Object.defineProperty`定义来禁止遍历constructor属性

  ```js
  function User() {}
  function Admin(name) {
    this.name = name;
  }
  
  Admin.prototype = Object.create(User.prototype);
  
  Object.defineProperty(Admin.prototype, "constructor", {
    value: Admin,
    enumerable: false  // 禁止遍历
  });
  
  let xj = new Admin("风暴游戏");
  console.log(xj);  // Admin {name: '风暴游戏'}
  for (let key in xj) {
    console.log(key);   // name
  }
  ```

  完全重写构建函数原型，只对后面应用对象有效

  ```js
  function User() {}
  const xj = new User();
  User.prototype = {
    show() {
      return "prototype show";
    }
  };
  const zs = new User();
  
  console.log(zs.show());   // prototype show
  console.log(xj.show());   // xj.show is not a functio
  ```

- 方法重写

  下面展示的例子需要重写父类方法的技巧

  ```js
  function Person() {}
  Person.prototype.getName = function() {
    console.log("person method");
  };
  
  function User(name) {}
  User.prototype = Object.create(Person.prototype);
  User.prototype.construstor = User;
  
  User.prototype.getNmae = function() {
    // 调用父级同名方法
    Person.prototype.getName.call(this);
    console.log("child method");
  };
  let xj = new User();
  xj.getName();   // person method
  ```

- 多态

  根据多种不同的形态产生不同的结果，下而会根据不同形态的对象得到了不同的结果

  ```js
  function User() {}
  User.prototype.show = function() {
    console.log(this.description());
  };
  
  function Admin() {}
  Admin.prototype = Object.create(User.prototype);
  Admin.prototype.description = function() {
    return "管理员在此";
  };
  
  function Member() {}
  Member.prototype = Object.create(User.prototype);
  Member.prototype.description = function() {
    return "我是会员";
  };
  
  function Enterprise() {}
  Enterprise.prototype = Object.create(User.prototype);
  Enterprise.prototype.description = function() {
    return "企业帐户";
  };
  
  for (const obj of [new Admin(), new Member(), new Enterprise()]) {
    obj.show();   // 管理员在此  我是会员  企业帐户
  }
  ```

  

## 4.深挖继承

继承是为了复用代码，继承的本质是将原型指向到另一个对象

- 构造函数

  我们希望调用父类构造函数完成对象的属性初始化，但像下面这样使用是不会成功的。因为此时 `this` 指向了window，无法为当前对象声明属性

  ```js
  // 严格模式下报错  Cannot set properties of undefined (setting 'name')
  function User(name) {
    this.name = name;
    console.log(this); // Window
  }
  User.prototype.getUserName = function() {
    return this.name;
  };
  
  function Admin(name) {
    User(name);
  }
  Admin.prototype = Object.create(User.prototype);
  Admin.prototype.role = function() {};
  
  let xj = new Admin("小杰");
  console.log(xj.getUserName()); //undefined
  ```

  解决上面的问题应使用 `call/apply` 为每个生成的对象设置属性

  ```js
  function User(name) {
    this.name = name;
    console.log(this); // Admin {name: '小杰'}
  }
  User.prototype.getUserName = function() {
    return this.name;
  };
  
  function Admin(name) {
    User.call(this, name);
  }
  Admin.prototype = Object.create(User.prototype);
  
  let xj = new Admin("小杰");
  console.log(xj.getUserName()); // 小杰
  ```

- 原型工厂

  原型工厂是将继承的过程封装，使用继承业务简单化

  ```js
  function extend(sub, sup) {
    sub.prototype = Object.create(sup.prototype);
    sub.prototype.constructor = sub;
  }
  
  function Access() {}
  function User() {}
  function Admin() {}
  function Member() {}
  
  extend(User, Access); //User继承Access
  extend(Admin, User); //Admin继承User
  extend(Member, Access); //Member继承Access
  
  Access.prototype.rules = function() {};
  User.prototype.getName = function() {};
  
  // 继承关系：Admin>User>Access>Object
  console.log(new Admin());   // Admin {}
  //继承关系：Member>Access>Object
  console.log(new Member());  // Member {}
  ```

- 对象工厂

  在原型继承基础上，将对象的生成使用函数完成，并在函数内部为对象添加属性或方法

  ```js
  function User(name, age) {
    this.name = name;
    this.age = age;
  }
  User.prototype.show = function() {
    console.log(this.name, this.age);
  };
  
  function Admin(name, age) {
    let instance = Object.create(User.prototype);
    User.call(instance, name, age);
    instance.role=function(){
      console.log('admin.role');
    }
    return instance;
  }
  let fb = Admin("小杰", 22);
  fb.show();  // 小杰 22
  
  function member(name, age) {
    let instance = Object.create(User.prototype);
    User.call(instance, name, age);
    return instance;
  }
  let zs = member("张三", 28);
  zs.show();    // 张三 28
  ```

- Mixin模式

  `JS`不能实现多继承，如果要使用多个类的方法时可以使用`mixin`混合模式来完成

  - `mixin` 类是一个包含许多供其它类使用的方法的类
  - `mixin` 类不用来继承做为其它类的父类

  下面示例中 `Admin`需要使用 `Request.prototype` 与 `Credit` 的功能，因为`JS` 是单继承，我们不得不将无关的类连接在一下，显然下面的代码实现并不佳

  ```js
  function extend(sub, sup) {
    sub.prototype = Object.create(sup.prototype);
    sub.prototype.constructor = sub;
  }
  function Credit() {}
  function Request() {}
  function User(name, age) {
    this.name = name;
    this.age = age;
  }
  extend(Request, Credit);
  extend(User, Request);
  Credit.prototype.total = function() {
    console.log("统计积分");
  };
  Request.prototype.ajax = function() {
    console.log("请求后台");
  };
  User.prototype.show = function() {
    console.log(this.name, this.age);
  };
  function Admin(...args) {
    User.apply(this, args);
  }
  extend(Admin, User);
  let fb = new Admin("小杰", 22);
  fb.show();    // 小杰 22
  fb.total(); //统计积分
  fb.ajax(); //请求后台
  ```

  下面分拆功能使用Mixin实现多继承，使用代码结构更清晰。只让 `Admin` 继承 `User` 原型

  ```js
  function extend(sub, sup) {
    sub.prototype = Object.create(sup.prototype);
    sub.prototype.constructor = sub;
  }
  function User(name, age) {
    this.name = name;
    this.age = age;
  }
  User.prototype.show = function() {
    console.log(this.name, this.age);
  };
  const Credit = {
    total() {
      console.log("统计积分");
    }
  };
  const Request = {
    ajax() {
      console.log("请求后台");
    }
  };
  
  function Admin(...args) {
    User.apply(this, args);
  }
  extend(Admin, User);
  Object.assign(Admin.prototype, Request, Credit);
  let fb = new Admin("小杰", 22);
  fb.show();    // 小杰 22
  fb.total(); //统计积分
  fb.ajax(); //请求后台
  ```

  `mixin` 类也可以继承其他类，比如下面的 `Create` 类获取积分要请求后台，就需要继承 `Request` 来完成

  - `super` 是在 `mixin` 类的原型中查找，而不是在 `User` 原型中

  ```js
  function extend(sub, sup) {
    sub.prototype = Object.create(sup.prototype);
    sub.prototype.constructor = sub;
  }
  function User(name, age) {
    this.name = name;
    this.age = age;
  }
  User.prototype.show = function() {
    console.log(this.name, this.age);
  };
  const Request = {
    ajax() {
      return "请求后台";
    }
  };
  const Credit = {
    __proto__: Request,
    total() {
      console.log(super.ajax() + ",统计积分");
    }
  };
  
  function Admin(...args) {
    User.apply(this, args);
  }
  extend(Admin, User);
  Object.assign(Admin.prototype, Request, Credit);
  let hd = new Admin("小杰", 22);
  hd.show();    // 小杰 22
  hd.total(); //统计积分
  hd.ajax(); //请求后台
  ```

- 实例操作

  使用 `call/apply` 制作选项卡

  ```js
  <style>
    * {
      padding: 0;
      margin: 0;
    }
  
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100vw;
      height: 100vh;
    }
  
    main {
      width: 400px;
      flex-direction: column;
      position: relative;
      margin-right: 20px;
    }
  
    main nav {
      display: flex;
      height: 50px;
      align-items: center;
    }
  
    main nav a {
      background: #95a5a6;
      margin-right: px;
      padding: 10px 20px;
      border: solid 1px #333;
      color: #fff;
      text-decoration: none;
    }
  
    main nav a:first-of-type {
      background: #e67e22;
    }
  
    section {
      height: 200px;
      width: 100%;
      background: #f1c40f;
      position: absolute;
      font-size: 5em;
      display: none;
    }
  
    .hd-tab section:first-of-type {
      display: block;
    }
  
    section:nth-child(even) {
      background: #27ae60;
    }
  </style>
  
  <body>
    <main class="tab1">
      <nav>
        <a href="javascript:;">后盾人</a>
        <a href="javascript:;">hdcms</a>
      </nav>
      <section>1</section>
      <section>2</section>
    </main>
    <main class="tab2">
      <nav>
        <a href="javascript:;">后盾人</a>
        <a href="javascript:;">hdcms</a>
      </nav>
      <section>1</section>
      <section>2</section>
    </main>
  </body>
  
  <script>
  	//继承工厂
    function extend(sub, sup) {
      sub.prototype = Object.create(sup.prototype);
      sub.prototype.constructor = sub;
    }
    
    //动作类
    function Animation() {}
    Animation.prototype.show = function() {
      this.style.display = "block";
    };
    //隐藏所有元素
    Animation.prototype.hide = function() {
      this.style.display = "none";
    };
    //必变元素集合背景
    Animation.prototype.background = function(color) {
      this.style.background = color;
    };
  	
  	//选项卡类
    function Tab(tab) {
      this.tab = tab;
      this.links = null;
      this.sections = null;
    }
    extend(Tab, Animation);
    Tab.prototype.run = function() {
      this.links = this.tab.querySelectorAll("a");
      this.sections = this.tab.querySelectorAll("section");
      this.bindEvent();
      this.action(0);
    };
    //绑定事件
    Tab.prototype.bindEvent = function() {
      this.links.forEach((el, i) => {
        el.addEventListener("click", () => {
          this.reset();
          this.action(i);
        });
      });
    };
    //点击后触发动作
    Tab.prototype.action = function(i) {
      this.background.call(this.links[i], "#e67e22");
      this.show.call(this.sections[i]);
    };
    //重置link与section
    Tab.prototype.reset = function() {
      this.links.forEach((el, i) => {
        this.background.call(el, "#95a5a6");
        this.hide.call(this.sections[i]);
      });
    };
    
    new Tab(document.querySelector(".tab1")).run();
    new Tab(document.querySelector(".tab2")).run();
  </script>
  ```

# 11.类

## 0.基础知识

为了和其他语言继承形态一致，JS提供了`class` 关键词用于模拟传统的`class` ，但底层实现机制依然是原型继承

`class` 只是语法糖为了让类的声明与继承更加简洁清晰

- 声明定义

  可以使用类声明和赋值表达式定义类，推荐使用类声明定义类

  ```js
  class User {}
  console.log(new User());
  
  let Admin = class {};
  console.log(new Admin());
  ```

  类方法间不需要逗号

  ```js
  class User {
    show() {}
    get() {
      console.log("get method");
    }
  }
  const xj = new User();
  xj.get();
  ```

- 构造函数

  使用 `constructor` 构造函数传递参数，下例中`show`为构造函数方法，`getName`为原型方法

  `constructor` 会在 new 时自动执行

  ```js
  class User {
  	constructor(name) {
        this.name = name;
        this.show = function() {};
      }
      getName() {
        return this.name;
      }
  }
  const xj = new User("小杰");
  console.log(xj);  // User {name: '小杰', show: ƒ}
  ```

  构造函数用于传递对象的初始参数，但不是必须定义的，如果不设置系统会设置如下类型

  - 子构造器中调用完`super` 后才可以使用 `this`

  - 至于 `super` 的概念会在后面讲到

    ```js
    constructor(...args) {
      super(...args);
    }
    ```

- 原理分析

  其实是函数

  ```js
  class User {
  }
  console.log(typeof User); //function
  ```

  `constructor` 用于定义函数代码，下面是与普通函数的对比，结构是一致的

  ![](https://i.loli.net/2021/09/21/RGEF9vdM8lCg14T.png)![image-20210906181651900](https://i.loli.net/2021/09/21/ktK4dEcnDRxp2vB.png)

  ```js
  class User {
    constructor(name) {
      this.name = name;
    }
    show() {}
  }
  console.dir(User);
  console.log(User == User.prototype.constructor);  // true
  
  function Fb(name) {
    this.name = name;
  }
  console.dir(Fb);
  console.log(Fb == Fb.prototype.constructor);    // true
  ```

  在类中定义的方法也保存在函数原型中

  ![image-20210906182426903](https://i.loli.net/2021/09/21/jT1wvk6VzrpdhxE.png)

  ```js
  class User {
    constructor(name) {
      this.name = name;
    }
    show() {}
  }
  console.dir(User);
  console.log(Object.getOwnPropertyNames(User.prototype));    // ['constructor', 'show']
  ```

  所以下面定义的类与下面使用函数的定义是一致的

  ```js
  class User {
    constructor(name) {
      this.name = name;
    }
    show() {
      console.log(this.name);
    }
  }
  
  function User(name) {
    this.name = name;
  }
  User.prototype.show = function() {
    console.log(this.name);
  }
  ```

- 属性定义

  在 `class` 中定义的属性为每个`new` 出的对象独立创建

  ```js
  class User {
    site = "风暴游戏";
    constructor(name) {
      this.name = name;
    }
    show() {
      console.log(this.site + "：" + this.name);
    }
  }
  let xj = new User("小杰");
  xj.show();  // 风暴游戏：小杰
  ```

- 函数差异

  `class` 是使用函数声明类的语法糖，但也有些区别

  `class` 中定义的方法不能枚举

  ```js
  class User {
    constructor(name) {
      this.name = name;
    }
    show() {
      console.log(this.name);
    }
  }
  let xj = new User("小杰");
  // 不会枚举出 show 属性
  for(const key in xj) {
    console.log(key);   // name
  }
  ```

- 严格属性

  `class` 默认使用`strict` 严格模式执行

  ```js
  class User {
    constructor(name) {
      this.name = name;
    }
    show() {
      function test() {
        // 严格模式下输出 undefined
        console.log(this);
      }
      test();
    }
  }
  let xj = new User("小杰");
  xj.show();    // undefined
  ```

## 1.静态访问

- 静态属性

  静态属性即为类设置属性，而不是为生成的对象设置，下面是原理实现

  ```js
  function User() {}
  User.site = "风暴游戏";
  console.dir(User);
  const fb = new User();
  console.log(fb.site); //undefiend
  console.log(User.site); // 风暴游戏
  ```

  在 `class` 中为属性添加 `static` 关键字即声明为静态属性

  可以把为所有对象使用的值定义为静态属性

  ```js
  class Request {
    static Host = "https://www.fengbaogame.com";
  
    query(api) {
      return Request.Host + "/" + api;
    }
  }
  let request = new Request();
  console.log(request);
  ```

- 静态方法

  指通过类访问不能使用对象访问的方法，比如系统的`Math.round()`就是静态方法

  一般来讲方法不需要对象属性参与计算就可以定义为静态方法

  ```js
  // 下面是静态方法实现原理
  function User() {
    this.show = function() {
      return "this is object function";
    }
  }
  User.show = function() {
    return "Welcome to fengbaogame";
  };
  let xj = new User();
  console.dir(xj.show());   // this is object function
  console.dir(User.show());   //  Welcome to fengbaogame
  ```

  在 `class` 内声明的方法前使用 `static` 定义的方法即是静态方法

  ```js
  class User {
    constructor(name) {
      this.name = name;
    }
    static create(name) {
      return new User(name);
    }
  }
  const xj = User.create("小杰");
  console.log(xj);	// User {name: '小杰'}
  ```

  下面使用静态方法在课程类中的使用

  ```js
  const data = [
    { name: "js", price: 100 },
    { name: "mysql", price: 212 },
    { name: "vue.js", price: 98 }
  ];
  class Lesson {
    constructor(data) {
      this.model = data;
    }
    get price() {
      return this.model.price;
    }
    get name() {
      return this.model.name;
    }
    //批量生成对象
    static createBatch(data) {
      return data.map(item => new Lesson(item));
    }
    //最贵的课程
    static MaxPrice(collection) {
      return collection.sort((a, b) => b.price - a.price)[0];
    }
  }
  const lessons = Lesson.createBatch(data);
  console.log(lessons);   // [Lesson, Lesson, Lesson]
  console.log(Lesson.MaxPrice(lessons).name);   // mysql
  ```

## 2.访问器

使用访问器可以对对象的属性进行访问控制，下面是使用访问器对私有属性进行管理

- 语法介绍

  - 使用访问器可以管控属性，有效的防止属性随意修改
  - 访问器就是在函数前加上 `get/set`修饰，操作属性时不需要加函数的扩号，直接用函数名

  ```js
  class User {
    constructor(name) {
      this.data = { name };
    }
    get name() {
      return this.data.name;
    }
    set name(value) {
      if(value.trim() == "") throw new Error("invalid params");
      this.data.name = value;
    }
  }
  let xj = new User("小杰");
  xj.name = "张三";
  console.log(xj.name);   // 张三
  ```

## 3.访问控制

- public

  `public` 指不受保护的属性，在类的内部与外部都可以访问到

  ```js
  class User {
    url = "fengbaogame.com";
    constructor(name) {
      this.name = name;
    }
  }
  let xj = new User("小杰");
  console.log(xj.name, xj.url);   // 小杰 fengbaogame.com
  ```

- protected

  protected是受保护的属性修释，不允许外部直接操作，但可以继承后在类内部访问

  - 命名保护

    将属性定义为以 `_` 开始，来告诉使用者这是一个私有属性，请不要在外部使用

    - 外部修改私有属性时可以使用访问器 `setter` 操作
    - 但这只是提示，就像吸烟时烟盒上的吸烟有害健康，但还是可以抽的

    ```js
    class Article {
      _host = "https://fengbaogane.com";
    
      set host(url) {
        if (!/^https:\/\//i.test(url)) {
          throw new Error("网址错误");
        }
        this._host = url;
      }
      
      lists() {
        return `${this._host}/article`;
      }
    }
    let article = new Article();
    console.log(article.lists()); // https://fengbaogane.com/article
    article.host = "https://fbgame.com";
    console.log(article.lists()); // https://fbgame.com/article
    ```

    继承时是可以使用的

    ```js
    class Common {
      _host = "https://fengboagame.com";
      set host(url) {
        if (!/^https:\/\//i.test(url)) {
          throw new Error("网址错误");
        }
        this._host = url;
      }
    }
    class Article extends Common {
      lists() {
        return `${this._host}/article`;
      }
    }
    let article = new Article();
    console.log(article.lists()); //https://fengboagame.com/article
    article.host = "https://fbgame.com";
    console.log(article.lists()); //https://fbgame.com/article
    ```

  - Symbol

    下面使用 `Symbol`定义私有访问属性，即在外部通过查看对象结构无法获取的属性

    ```js
    const protecteds = Symbol();
    class Common {
      constructor() {
        this[protecteds] = {};
        this[protecteds].host = "https://fengbaogame.com";
      }
      set host(url) {
        if (!/^https?:/i.test(url)) {
          throw new Error("非常网址");
        }
        this[protecteds].host = url;
      }
      get host() {
        return this[protecteds].host;
      }
    }
    class User extends Common {
      constructor(name) {
        super();
        this[protecteds].name = name;
      }
      get name() {
        return this[protecteds].name;
      }
    }
    let fb = new User("风暴游戏");
    fb.host = "https://www.fbgame.com";
    console.log(fb[Symbol()]);  // undefined
    console.log(fb.name);   // 风暴游
    ```

  - WeakMap

    **WeakMap** 是一组键/值对的集，下面利用`WeakMap`类型特性定义私有属性

    ```js
    const _host = new WeakMap();
    class Common {
      constructor() {
        _host.set(this, "https://fengbaogame.com");
      }
      set host(url) {
        if (!/^https:\/\//i.test(url)) {
          throw new Error("网址错误");
        }
        _host.set(this, url);
      }
    }
    class Article extends Common {
      constructor() {
        super();
      }
      lists() {
        return `${_host.get(this)}/article`;
      }
    }
    let article = new Article();
    console.log(article.lists()); //https://fengbaogame.com/article
    article.host = "https://fbgame.com";
    console.log(article.lists()); //https://fbgame.com/article
    ```

    也可以统一定义私有属性

    ```js
    const protecteds = new WeakMap();
    class Common {
      constructor() {
        protecteds.set(this, {
          host: "https://fengbaogame.com",
          port: "80"
        });
      }
      set host(url) {
        if (!/^https:\/\//i.test(url)) {
          throw new Error("网址错误");
        }
        protecteds.set(this, { ...protecteds.get(this), host: url });
      }
    }
    class Article extends Common {
      constructor() {
        super();
      }
      lists() {
        return `${protecteds.get(this).host}/article`;
      }
    }
    let article = new Article();
    console.log(article.lists()); //https://fengbaogame.com/article
    article.host = "https://fbgame.com";
    console.log(article.lists()); //https://fbgame.com/article
    ```

- private

  `private` 指私有属性，只在当前类可以访问到，并且不允许继承使用

  - 为属性或方法名前加 `#` 为声明为私有属性

  - 私有属性只能在声明的类中使用

  下面声明私有属性 `#host` 与私有方法 `check` 用于检测用户名

  ```js
  class User {
    //private
    #host = "https://fengbaogame.com";
    constructor(name) {
      this.name = name ;
      this.#check(name);
    }
    set host(url) {
      if (!/^https?:/i.test(url)) {
        throw new Error("非常网址");
      }
      this.#host = url;
    }
    get host() {
      return this.#host;
    }
    #check = () => {
      if (this.name.length <= 5) {
        throw new Error("用户名长度不能小于五位");
      }
      return true;
    };
  }
  let hd = new User("后盾人在线教程");
  hd.host = "https://www.fbgame.com";
  console.log(hd.host);   // https://www.fbgame.com
  ```

- 属性保护

  保护属性并使用访问器控制

  ```js
  const protecteds = Symbol("protected");
  class User {
    constructor(name) {
      this[protecteds] = { name };
    }
    get name() {
      return this[protecteds].name;
    }
    set name(value) {
      if (value.trim() == "") throw new Error("invalid params");
      this[protecteds].name = value;
    }
  }
  let fb = new User("小杰");
  fb.name = "风暴游戏";
  console.log(fb.name); // 风暴游戏
  console.log(Object.keys(fb));   // []
  ```

## 4.详解继承

- 属性继承

  属性继承的原型如下

  ```js
  function User(name) {
    this.name = name;
  }
  function Admin(name) {
    User.call(this, name); 
  }
  let fb = new Admin("风暴游戏");
  console.log(fb);    // Admin {name: '风暴游戏'}
  ```

  这就解释了为什么在子类构造函数中要先执行`super`

  ```js
  class User {
    constructor(name) {
      this.name = name;
    }
  }
  class Admin extends User {
    constructor(name) {
      super(name);
    }
  }
  let fb = new Admin("风暴游戏");
  console.log(fb);  // Admin {name: '风暴游戏'}
  ```

- 继承原理

  `class` 继承内部使用原型继承

  ![image-20191211135724814](https://i.loli.net/2021/09/21/rw6tsi1j5GOWnvB.png)

  ```js
  class User {
    show() {
      console.log("user.show");
    }
  }
  class Admin extends User {
    info() {
      this.show();
    }
  }
  let fb = new Admin();
  console.dir(fb);	// Admin
  ```

- 方法继承

  原生的继承主要是操作原型链，实现起来比较麻烦，使用 `class` 就要简单的多了

  - 继承时必须在子类构造函数中调用 super() 执行父类构造函数
  - super.show() 执行父类方法

  下面是子类继承了父类的方法`show`

  ```js
  class Person {
    constructor(name) {
      this.name = name;
    }
    show() {
      return `风暴游戏: ${this.name}`;
    }
  }
  class User extends Person {
    constructor(name) {
      super(name);
    }
    run() {
      return super.show();
    }
  }
  const xj = new User("小杰");
  console.dir(xj.run());    // 风暴游戏: 小杰
  ```

  可以使用 `extends` 继承表达式返回的类

  ```js
  function controller() {
    return class {
      show() {
        console.log("user.show");
      }
    };
  }
  class Admin extends controller() {
    info() {
      this.show();
    }
  }
  let fb = new Admin();
  console.dir(fb);
  ```

- super

  表示从当前原型中执行方法

  super 一直指向当前对象

  下面是使用 this 模拟super，会有以下问题

  ```js
  // 但this指向当前对象，结果并不是 admin的name值
  let user = {
    name: "user",
    show() {
      return this.name;
    }
  };
  let admin = {
    __proto__: user,
    name: "admin",
    show() {
      return this.__proto__.show();
    }
  };
  console.log(admin.show());  // user
  ```

  为了解决以上问题，需要调用父类方法时传递`this`

  ```js
  let user = {
    name: "user",
    show() {
      return this.name;
    }
  };
  let admin = {
    __proto__: user,
    name: "admin",
    show() {
      return this.__proto__.show.call(this);
    }
  };
  console.log(admin.show());  // admin
  ```

  上面看似结果正常，但如果是多层继承时，会出现新的问题

  ```js
  // 因为始终传递的是当前对象this ，造成从 this 原型循环调用
  let common = {
    show() {
      console.log("common.init");
    }
  };
  let user = {
    __proto__: common,
    name: "user",
    show() {
      return this.__proto__.show.call(this);
    }
  };
  let admin = {
    __proto__: user,
    name: "admin",
    get() {
      return this.__proto__.show.call(this);
    }
  };
  console.log(admin.get());
  ```

  为了解决以上问题 `js` 提供了 `super` 关键字

  - 使用 `super` 调用时，在所有继承中 `this` 始终为调用对象
  - `super` 是用来查找当前对象的原型，而不像上面使用 `this` 查找原型造成死循环
  - 也就是说把查询原型方法的事情交给了 `super`，`this` 只是单纯的调用对象在各个继承中使用

  ```js
  let common = {
    show() {
      return this.name;
    }
  };
  let user = {
    __proto__: common,
    name: "user",
    show() {
      return super.show(this);
    }
  };
  let admin = {
    __proto__: user,
    name: "admin",
    get() {
      return super.show();
    }
  };
  console.log(admin.get());   // admin
  ```

  `super` 只能在类或对象的方法中使用，而不能在函数中使用，下面将产生错误

  ```js
  let user = {
    name: "user",
    show() {
      return this.name;
    }
  };
  let admin = {
    __proto__: user,
    name: "admin",
    get: function() {
      return super.show();
    }
  };
  console.log(admin.get());   // 'super' keyword unexpected here
  ```

- constructor

  super` 指调父类引用，在构造函数`constructor` 中必须先调用`super()

  - `super()` 指调用父类的构造函数
  - 必须在 `constructor` 函数里的`this` 调用前执行 `super()`

  ```js
  class User {
    constructor(name) {
      this.name = name;
    }
    show() {
      console.log(this.name);
    }
  }
  class Admin extends User {
    constructor(name) {
      super(name);
    }
  }
  let fb = new Admin("风暴游戏");
  fb.show();    // 风暴游戏
  ```

  `constructor` 中先调用 `super` 方法的原理如下

  ```js
  function Parent(name) {
    this.name = name;
  }
  function User(...args) {
    Parent.apply(this, args);
  }
  User.prototype = Object.create(User.prototype)
  User.prototype.constructor = User;
  const fb = new User("风暴游戏");
  console.log(fb.name);   // 风暴游戏
  ```

- 父类方法

  使用`super` 可以执行父类方法

  不添加方法名是执调用父类构造函数

  ```js
  class User {
    constructor(name) {
      this.name = name;
    }
    getName() {
      return this.name;
    }
  }
  class Admin extends User {
    constructor(name) {
      super(name);
    }
  }
  const fb = new Admin("风暴游戏");
  console.log(fb.getName());    // 风暴游戏
  ```

  下面是通过父类方法获取课程总价

  ```js
  class Controller {
    sum() {
      return this.data.reduce((t, c) => t + c.price, 0);
    }
  } 
  class Lesson extends Controller {
    constructor(lessons) {
      super();
      this.data = lessons;
    }
    info() {
      return {
        totalPrice: super.sum(),
        data: this.data
      };
    }
  }
  let data = [
    { name: "js", price: 100 },
    { name: "mysql", price: 212 },
    { name: "vue.js", price: 98 }
  ];
  const fb = new Lesson(data);
  console.log(fb.info());   // {totalPrice: 410, data: Array(3)}
  ```

- 方法覆盖

  子类存在父类同名方法时使用子类方法

  ```js
  class User {
    constructor(name) {
      this.name = name;
    }
    say() {
      return this.name;
    }
  }
  class Admin extends User {
    constructor(name) {
      super(name);
    }
    say() {
      return "风暴游戏：" + super.say();
    }
  }
  const xj = new Admin("小杰");
  console.log(xj.say());    // 风暴游戏：小杰
  ```

  下面是覆盖父类方法，只获取课程名称

  ```js
  class Controller {
    say() {
      return this.name;
    }
    total() {
      return this.data.reduce((t, c) => t + c.price, 0);
    }
    getByKey(key) {
      return this.data.filter(item => item.name.includes(key));
    }
  }
  class Lesson extends Controller {
    constructor(lessons) {
      super();
      this.data = lessons;
    }
    getByKey(key) {
      return super.getByKey(key).map(item => item.name);
    }
  }
  let data = [
    { name: "js", price: 100 },
    { name: "mysql", price: 212 },
    { name: "vue.js", price: 98 }
  ];
  const fb = new Lesson(data);
  console.log(fb.getByKey("js"));   // ['js', 'vue.js']
  ```

- 静态继承

  静态的属性和方法也是可以被继承使用的，下面是原理分析

  ```js
  function User() {}
  User.site = "风暴游戏";
  User.url = function() {
    return "fengbaogame.com";
  };
  function Admin() {}
  Admin.__proto__ = User;
  console.dir(Admin);   // ƒ Admin()
  console.log(Admin.url());   // fengbaogame.com
  ```

  下面使用 `class` 来演示静态继承

  ```js
  class User {
    static site = "风暴游戏";
    static host() {
      return "fengbaogame.com";
    }
  }
  class Admin extends User {}
  console.dir(Admin);   // class Admin
  ```

- instanceof

  使用 `instanceof` 用于检测，下面是在原型中的分析

  ```js
  function User() {}
  function Admin() {}
  Admin.prototype = Object.create(User.prototype);
  let fb = new Admin();
  console.log(fb instanceof Admin); //true
  console.log(fb instanceof User); //true
  
  console.log(fb.__proto__ == Admin.prototype);   // true
  console.log(fb.__proto__.__proto__ == User.prototype);  // true
  ```

  下面是递归检测原型的代码，帮助你分析 `instanceof` 的原理

  ```js
  function checkPrototype(obj, constructor) {
    if (!obj.__proto__) return false;
    if (obj.__proto__ == constructor.prototype) return true;
    return checkPrototype(obj.__proto__, constructor);
  }
  ```

  `class` 内部实现就是基于原型，所以使用`instanceof` 判断和上面原型是一样的

  ```js
  class User {}
  class Admin extends User {}
  let hd = new Admin();
  console.log(hd instanceof Admin);   // true
  console.log(hd instanceof User);    // true
  ```

- ### isPrototypeOf

  使用 `isPrototypeOf` 判断一个对象是否在另一个对象的原型链中，下面是原理分析

  ```js
  const a = {};
  const b = {
    __proto__: a
  };
  const c = {
    __proto__: b
  };
  console.log(a.isPrototypeOf(b)); //true
  console.log(a.isPrototypeOf(c)); //true
  ```

  下面在使用 `class` 语法中使用

  ```js
  class User {}
  class Admin extends User {}
  let hd = new Admin();
  console.log(Admin.prototype.isPrototypeOf(hd));   // true
  console.log(User.prototype.isPrototypeOf(hd));    // true
  ```

- 继承内置类

  使用原型扩展内置类

  ```js
  function Arr(...args) {
    args.forEach(item => this.push(item));
    this.first = function() {
      return this[0];
    };
    this.max = function() {
      return this.data.sort((a, b) => b - a)[0];
    };
  }
  let a = [1, 23];
  Arr.prototype = Object.create(Array.prototype);
  let arr = new Arr("风暴游戏", 2, 3);
  console.log(arr.first());   // 风暴游戏
  ```

  使用 `class`扩展内置类

  ```js
  class NewArr extends Array {
    constructor(...args) {
      super(...args);
    }
    first() {
      return this[0];
    }
    add(value) {
      this.push(value);
    }
    remove(value) {
      let pos = this.findIndex(curValue => {
        return curValue == value;
      });
      this.splice(pos, 1);
    }
  }
  let fb = new NewArr(5, 3, 2, 1);
  console.log(fb.length); //4
  console.log(fb.first()); //5
  
  fb.add("fengbaogame");
  console.log(fb.join(",")); //5,3,2,1,fengbaogame
  
  fb.remove("3");
  console.log(fb.join(",")); //5,2,1,fengbaogame
  ```

- mixin

  关于`mixin` 的使用在原型章节已经讨论过，在`class` 使用也是相同的原理

  `JS`不能实现多继承，如果要使用多个类的方法时可以使用`mixin`混合模式来完成

  - `mixin` 类是一个包含许多供其它类使用的方法的类
  - `mixin` 类不用来继承做为其它类的父类

  ```js
  const Tool = {
    max(key) {
      return this.data.sort((a, b) => b[key] - a[key])[0];
    }
  };
  
  class Lesson {
    constructor(lessons) {
      this.lessons = lessons;
    }
    get data() {
      return this.lessons;
    }
  }
  
  Object.assign(Lesson.prototype, Tool);
  const data = [
    { name: "js", price: 100 },
    { name: "mysql", price: 212 },
    { name: "vue.js", price: 98 }
  ];
  let fb = new Lesson(data);
  console.log(fb.max("price"));	// {name: 'mysql', price: 212}
  ```

- 实例操作

  ```js
  <style>
    * {
      padding: 0;
      margin: 0;
      box-sizing: content-box;
    }
    body {
      padding: 30px;
    }
    .slide {
      width: 300px;
      display: flex;
      flex-direction: column;
      /* box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3); */
    }
    .slide dt {
      height: 30px;
      background: #34495e;
      color: white;
      display: flex;
      align-items: center;
      padding-left: 10px;
      cursor: pointer;
    }
    .slide dt:first-of-type {
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
    }
    .slide dd {
      height: 100px;
      background: #f1c40f;
      overflow: hidden;
    }
    .slide dd div {
      padding: 10px;
    }
    .slide dd:last-of-type {
      border-bottom-left-radius: 10px;
      border-bottom-right-radius: 10px;
    }
  </style>
  <body>
    <div class="slide s1">
      <dt>风暴游戏</dt>
      <dd>
        <div>fengbaogame.com</div>
      </dd>
      <dt>风暴游戏</dt>
      <dd>
        <div>fbgame.com</div>
      </dd>
      <dt>风暴游戏</dt>
      <dd>
        <div>fbgame.com</div>
      </dd>
    </div>
  </body>
  
  <script>
    class Animation {
      constructor(el) {
        this.el = el;
        this.timeout = 5;
        this.isShow = true;
        this.defaultHeight = this.height;
      }
      hide(callback) {
        this.isShow = false;
        let id = setInterval(() => {
          if (this.height <= 0) {
            clearInterval(id);
            callback && callback();
            return;
          }
          this.height = this.height - 1;
        }, this.timeout);
      }
      show(callback) {
        this.isShow = false;
        let id = setInterval(() => {
          if (this.height >= this.defaultHeight) {
            clearInterval(id);
            callback && callback();
            return;
          }
          this.height = this.height + 1;
        }, this.timeout);
      }
      get height() {
        return window.getComputedStyle(this.el).height.slice(0, -2) * 1;
      }
      set height(height) {
        this.el.style.height = height + "px";
      }
    }
    class Slide {
      constructor(el) {
        this.el = document.querySelector(el);
        this.links = this.el.querySelectorAll("dt");
        this.panels = [...this.el.querySelectorAll("dd")].map(
          item => new Panel(item)
        );
        this.bind();
      }
      bind() {
        this.links.forEach((item, i) => {
          item.addEventListener("click", () => {
            this.action(i);
          });
        });
      }
      action(i) {
        Panel.hideAll(Panel.filter(this.panels, i), () => {
          this.panels[i].show();
        });
      }
    }
    class Panel extends Animation {
      static num = 0;
      static hideAll(items, callback) {
        if (Panel.num > 0) return;
        items.forEach(item => {
          Panel.num++;
          item.hide(() => {
            Panel.num--;
          });
        });
        callback && callback();
      }
      static filter(items, i) {
        return items.filter((item, index) => index != i);
      }
    }
    let hd = new Slide(".s1");
  </script>
  ```

# 12.模块设计

## 0.模块设计

- 使用分析

  项目变大时需要把不同的业务分割成多个文件，这就是模块的思想。模块是比对象与函数更大的单元，使用模块组织程序便于维护与扩展

  生产环境中一般使用打包工具如 `webpack` 构建，他提供更多的功能。但学习完本章节后会再学习打包工具会变得简单

  - 模块就是一个独立的文件，里面是函数或者类库
  - 虽然JS没有命名空间的概念，使用模块可以解决全局变量冲突
  - 模块需要隐藏内部实现，只对外开发接口
  - 模块可以避免滥用全局变量，造成代码不可控
  - 模块可以被不同的应用使用，提高编码效率

- 实现原理

  在过去JS不支持模块时我们使用`AMD/CMD（浏览器端使用）`、`CommonJS（Node.js使用）`、`UMD(两者都支持)`等形式定义模块

  AMD代表性的是 `require.js`，CMD 代表是淘宝的 `seaJS` 框架

  下面通过定义一个类似 `require.js` 的 `AMD` 模块管理引擎，来体验模块的工作原理

  ```js
  let module = (function() {
    //模块列表集合
    const moduleLists = {};
    function define(name, modules, action) {
      modules.map((m, i) => {
        modules[i] = moduleLists[m];
      });
      //执行并保存模块
      moduleLists[name] = action.apply(null, modules);
    }
  
    return { define };
  })();
  
  //声明模块不依赖其它模块
  module.define("fb", [], function() {
    return {
      show() {
        console.log("fb module show");
      }
    };
  });
  
  //声明模块时依赖其它模块
  module.define("xj", ["fb"], function(fb) {
    fb.show();    // fb module show
  });
  ```


## 1.基础知识

- 标签使用

  在浏览器中使用以下语法靠之脚本做为模块使用，这样就可以在里面使用模块的代码了

  在html文件中导入模块，需要定义属性 `type="module"`

  ```js
  <script type="module"></script>
  ```

- 模块路径

  在浏览器中引用模块必须添加路径如`./` ，但在打包工具如`webpack`中则不需要，因为他们有自己的存放方式

  测试的 `fb.js` 的模块内容如下

  ```js
  export let fb = {
    name: "风暴游戏"
  };
  ```

  下面没有指定路径将发生错误

  ```js
  <script type="module">
    import { fb } from "fb.js";
  </script>
  ```

  正确使用需要添加上路径

  ```js
  <script type="module">
    import { fb } from "./fb.js";
  </script>
  ```

- 延迟解析

  模块总是会在所有html解析后才执行，下面的模块代码可以看到后加载的 `button` 按钮元素

  建议为用户提供加载动画提示，当模块运行时再去掉动画

  ```js
  <body>
    <script type="module">
      console.log(document.querySelector("button")); // <button>风暴游戏</button>
    </script>
    <script>
      console.log(document.querySelector("button")); // null
    </script>
    <button>风暴游戏</button>
  </body>
  ```

- 严格模式

  模块默认运行在严格模式，以下代码没有使用声明语句将报错

  ```js
  <script type="module">
  	fb = "houdunren"; // Error
  </script>
  ```

  下面的 `this` 也会是 `undefined`

  ```js
  <script>
    console.log(this); //Window
  </script>
  <script type="module">
    console.log(this); //undefiend
  </script>
  ```

- 作用域

  模块都有独立的顶级作用域，下面的模块不能互相访问

  ```js
  <script type="module">
    let fb = "fengbaogame.com";
  </script>
  
  <script type="module">
    alert(fb); // Error
  </script>
  ```

  单独文件作用域也是独立的，下面的模块 `1.2.js` 不能访问模块 `1.1.js` 中的数据

  ```js
  <script type="module" src="1.1.js"></script>
  <script type="module" src="1.2.js"></script>
  
  // 文件内容如下
  # 1.1.js
  let fb = "fengbaogame";
  
  # 1.2.js
  console.log(fb)
  ```

- 预解析

  模块在导入时只执行一次解析，之后的导入不会再执行模块代码，而使用第一次解析结果，并共享数据

  - 可以在首次导入时完成一些初始化工作
  - 如果模块内有后台请求，也只执行一次即可

  引入多入`hd.js` 脚本时只执行一次

  ```js
  <script type="module" src="fb.js"></script>
  <script type="module" src="fb.js"></script>
  
  #hd.js内容如下
  console.log("fengbaogame.com");
  ```

  下面在导入多次 `hd.js` 时只解析一次

  ```js
  <script type="module">
    import "./fb.js";
    import "./fb.js";
  </script>
  
  # hd.js内容如下
  console.log("fengbaogame.com");
  ```

## 2.导入导出

ES6使用基于文件的模块，即一个文件一个模块

- 使用`export` 将开发的接口导出

- 使用`import` 导入模块接口

- 使用`*`可以导入全部模块接口

- 导出是以引用方式导出，无论是标量还是对象，即模块内部变量发生变化将影响已经导入的变量

- 导出模块

  下面定义模块 `modules/fengbaogame.js` ，使用 `export` 导出模块接口，没有导出的变量都是模块私有的

  下面是对定义的 `fb.js` 模块，分别导出内容

  ```js
  export const site = "风暴游戏";
  export const func = function() {
    return "is a module function";
  };
  export class User {
    show() {
      console.log("user.show");
    }
  }
  ```

  下面定义了`hd.js` 模块，并批量导出

  ```js
  const site = "风暴游戏";
  const func = function() {
    return "is a module function";
  };
  class User {
    show() {
      console.log("user.show");
    }
  }
  export { site, func, User };
  ```

- 具名导入

  下面导入上面定义的 `hd.js` 模块，分别导入模块导出的内容

  ```js
  <script type="module">
    import { User, site, func } from "./fb.js";
    console.log(site);
    console.log(User);
  </script>
  ```

  像下面这样在 `{}` 中导入是错误的，模块默认是在顶层静态导入，这是为了分析使用的模块方便打包

  ```js
  if (true) {
    import { site, func } from "./fb.js"; // Error
  }
  ```

- 批量导入

  如果要导入的内容比较多，可以使用 `*` 来批量导入

  ```js
  <script type="module">
    import * as api from "./fb.js";
    console.log(api.site);
    console.log(api.User);
  </script>
  ```

- 导入建议

  因为以下几点，我们更建议使用明确导入方式

  - 使用`webpack` 构建工具时，没有导入的功能会删除节省文件大小
  - 可以更清晰知道都使用了其他模块的哪些功能

## 3.别名使用

- 导入别名

  可以为导入的模块重新命名，下面是为了测试定义的 `fb.js` 模块内容

  - 有些导出的模块命名过长，起别名可以理简洁
  - 本模块与导入模块重名时，可以通过起别名防止错误

  ```js
  const site = "风暴游戏";
  const func = function() {
    return "is a module function";
  };
  class User {
    show() {
      console.log("user.show");
    }
  }
  export { site, func, User };
  ```

  模块导入使用 `as` 对接口重命名，本模块中已经存在 `func` 变量，需要对导入的模块重命名防止重名错误

  ```js
  <script type="module">
    import { User as user, func as action, site as name } from "./fb.js";
    let func = "fengbaogame";
    console.log(name);
    console.log(user);
    console.log(action);
  </script>
  ```

- 导出别名

  模块可以对导出给外部的功能起别名，下面是`fb.js` 模块对导出给外部的模块功能起了别名

  ```js
  const site = "风暴游戏";
  const func = function() {
    console.log("is a module function");
  };
  class User {
    show() {
      console.log("user.show");
    }
  }
  export { site, func as action, User as user };
  ```

  这时就要使用新的别名导入了

  ```js
  <script type="module">
    import { user, action } from "./fb.js";
    action();
  </script>
  ```

## 4.默认导出

很多时候模块只是一个类，也就是说只需要导入一个内容，这地可以使用默认导入。

使用`default` 定义默认导出的接口，导入时不需要使用 `{}`

- 可以为默认导出自定义别名

- 只能有一个默认导出

- 默认导出可以没有命名

- 单一导出

  下面是`fb.js` 模块内容，默认只导出一个类。并且没有对类命名，这是可以的

  ```js
  export default class {
    static show() {
      console.log("User.method");
    }
  }
  ```

  从程序来讲如果将一个导出命名为 `default` 也算默认导出

  ```js
  class User {
    static show() {
      console.log("User.method");
    }
  }
  export { User as default };
  ```

  导入时就不需要使用 `{}` 来导入了

  ```js
  <script type="module">
    import User from "./fb.js";
    User.show();
  </script>
  ```

  默认导出的功能可以使用任意变量接收

  ```js
  <script type="module">
    import fb from "./fb.js";
    fb.show();
  </script>
  ```

- 混合导出

  模块可以存在默认导出与命名导出

  使用`export default` 导出默认接口，使用 `export {}` 导入普通接口

  ```js
  const site = "风暴游戏";
  const func = function() {
    console.log("is a module function");
  };
  export default class {
    static show() {
      console.log("user.show");
    }
  }
  export { site, func };
  ```

  也可以使用以下方式导出模块

  ```js
  const site = "风暴游戏";
  const func = function() {
    console.log("is a module function");
  };
  class User {
    static show() {
      console.log("user.show");
    }
  }
  export { site, func, User as default };
  ```

  导入默认接口时不需要使用 `{}` ，普通接口还用 `{}` 导入

  ```js
  <script type="module">
  	//可以将 fb 替换为任何变量
    import fb from "./fb.js";
    import { site } from "./fb.js";
    console.log(site);
    hd.show();
  </script>
  ```

  可以使用一条语句导入默认接口与常规接口

  ```js
  import show, { name } from "/modules/fengbaogame.js";
  ```

  也可以使用别名导入默认导出

  ```js
  import { site, default as hd } from "./fb.js";
  console.log(site);
  fb.show();
  ```

  如果是批量导入时，使用 `default` 获得默认导出

  ```js
  <script type="module">
    import * as api from "./fb.js";
    console.log(api.site);
    api.default.show();
  </script>
  ```

- 使用建议

  对于默认导出和命名导出有以下建议

  不建议使用默认导出，会让开发者导入时随意命名

  ```js
  import fb from "./fb.js";
  import xj from "./fb.js";
  ```

  如果使用默认导入最好以模块的文件名有关联，会使用代码更易阅读

  ```js
  import fb from "./fb.js";
  ```

## 5.导出合并

- 解决问题

  可以将导入的模块重新导出使用，比如项目模块比较多如下所示，这时可以将所有模块合并到一个入口文件中

  这样只需要使用一个模块入口文件，而不用关注多个模块文件

  ```js
  |--fb.js
  |--fengbaogame.js
  ...
  ```

- 实际使用

  下面是 `fb.js` 模块内容

  ```js
  const site = "风暴游戏";
  const func = function() {
    console.log("is a module function");
  };
  export { site, func };
  ```

  下面是 `fengbaogame.js` 模块内容

  ```js
  export default class {
    static get() {
      console.log("fengabogame.js.get");
    }
  }
  ```

  下面是 `index.js` 模块内容，使用 `*` 会将默认模块以 `default` 导出

  ```js
  export * as fb from "./fb.js";
  // 默认模块需要单独导出
  export { default as fengbaogame } from "./fengbaogame.js";
  // 以下方式导出默认模块是错误的
  // export fengbaogame from "./fengbaogame.js";
  ```

  使用方法如下

  ```js
  <script type="module">
    import * as api from "./index.js";
    console.log(api);
    api.fengbaogame.get();
    console.log(api.fb.site);
  </script>
  ```

## 6.动态加载

使用 `import` 必须在顶层静态导入模块，而使用`import()` 函数可以动态导入模块，它返回一个 `promise` 对象

- 静态导入

  使用 `import` 顶层静态导入，像下面这样在 `{}` 中导入是错误的，这是为了分析使用的模块方便打包，所以系统禁止这种行为

  ```js
  if (true) {
    import { site, func } from "./fb.js"; // Error
  }
  ```

- 动态导入

  使用 `import` 顶层静态导入，像下面这样在 `{}` 中导入是错误的，这是为了分析使用的模块方便打包，所以系统禁止这种行为

  ```js
  if (true) {
    import { site, func } from "./fb.js"; // Error
  }
  ```

- 动态使用

  测试用的 `fb.js` 模块内容如下

  ```js
  const site = "风暴游戏";
  const func = function() {
    console.log("is a module function");
  };
  export { site, func };
  ```

  使用 `import()` 函数可以动态导入，实现按需加载

  ```js
  <script>
    if (true) {
      let fb = import("./fb.js").then(module => {
        console.log(module.site);
      });
    }
  </script>
  ```

  下面是在点击事件发生后按需要加载模块

  ```js
  <button>风暴游戏</button>
  <script>
    document.querySelector("button").addEventListener("click", () => {
      let fb = import("./fb.js").then(module => {
        console.log(module.site);
      });
    });
  </script>
  ```

  因为是返回的对象可以使用解构语法

  ```js
  <button>风暴游戏</button>
  <script>
    document.querySelector("button").addEventListener("click", () => {
      let fb = import("./fb.js").then(({ site, func }) => {
        console.log(site);
      });
    });
  </script>
  ```

## 7.指令总结

|                       表达式                       |       说明       |
| :------------------------------------------------: | :--------------: |
|              export function show(){}              |     导出函数     |
|            export const name='风暴游戏'            |     导出变量     |
|                export class User{}                 |      导出类      |
|                export default show                 |     默认导出     |
|     const name = ''风暴游戏'<br/>export {name}     | 导出已经存在变量 |
|              export {name as fb_name}              |     别名导出     |
|      import defaultVar from 'fengbaogame.js'       |   导入默认导出   |
|           import {name,show} from 'a.j'            |   导入命名导出   |
| Import {name as fbName,show} from 'fengbaogame.js' |     别名导入     |
|       Import * as api from 'fengbaogame.js'        |   导入全部接口   |

## 8.编译打包

编译指将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。

首先登录 `https://nodejs.org/en/` 官网下载安装`Node.js`，我们将使用其他的npm命令，npm用来安装第三方类库。

在命令行输入 `node -v` 显示版本信息表示安装成功

- 安装配置

  使用以下命令生成配置文件 `package.json`

  ```js
  npm init -y
  ```

  修改`package.json`添加打包命令

  ```js
  ...
  "main": "index.js",
  "scripts": {
  	"dev": "webpack --mode development --watch"
  },
  ...
  ```

  安装webpack工具包，如果安装慢可以使用淘宝 [cnpm (opens new window)](https://npm.taobao.org/)命令

  ```js
  npm i webpack webpack-cli --save-dev
  ```

- 目录结构

  ```js
  index.html
  --dist #压缩打包后的文件
  --src
  ----index.js  #入口
  ----style.js //模块
  ```

  index.html内容如下

  ```js
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <meta http-equiv="X-UA-Compatible" content="ie=edge" />
      <title>Document</title>
    </head>
    <body>
      <script src="dist/main.js"></script>
    </body>
  </html>
  ```

  index.js内容如下

  ```js
  import style from "./style";
  new style().init();
  ```

  style.js

  ```js
  export default class User {
    constructor() {}
    init() {
      document.body.style.backgroundColor = "green";
    }
  }
  ```

- 执行打包

  运行以下命令将生成打包文件到 `dist`目录，因为在命令中添加了 `--watch`参数，所以源文件编辑后自动生成打包文件。

  ```js
  npm run dev
  ```

# 13.正则表达式

## 0.基础知识

正则表达式是在宿主环境下运行的，如`js/php/node.js` 等

- 对比分析

  与普通函数操作字符串来比较，正则表达式可以写出更简洁、功能强大的代码

  下面使用获取字符串中的所有数字来比较函数与正则的差异

  ```js
  let fb = "fengbaogame2200xiaojie9988";
  let nums = [...fb].filter(a => !Number.isNaN(parseInt(a)));
  console.log(nums.join(""));   // 22009988
  ```

  使用正则表达式将简单得多

  ```js
  let fb = "fengbaogame2200xiaojie9988";
  console.log(fb.match(/\d/g).join(""));  // 22009988
  ```

- 创建正则

  JS提供字面量与对象两种方式创建正则表达式

  - 字面量创建

    使用`//`包裹的字面量创建方式是推荐的作法，但它不能在其中使用变量

    ```js
    let fb = "fengbaogame.com";
    console.log(/e/.test(fb)); // true
    ```

    下面尝试使用 `a` 变量时将不可以查询

    ```js
    let fb = "fengbaogame.com";
    let a = "e";
    console.log(/a/.test(fb)); // true
    ```

    虽然可以使用 `eval` 转换为js语法来实现将变量解析到正则中，但是比较麻烦，所以有变量时建议使用下面的对象创建方式

    ```js
    let fb = "fengbaogame.com";
    let a = "o";
    console.log(eval(`/${a}/`).test(fb)); //true
    ```

  - 对象创建

    当正则需要动态创建时使用对象方式

    ```js
    let fb = "fengbaogame.com";
    let web = "fengbaogame";
    let reg = new RegExp(web);
    console.log(reg.test(fb)); //true
    ```

    根据用户输入高亮显示内容，支持用户输入正则表达式

    ```js
    
    ```

    

## 1.元子字符

## 2.模式修饰

## 3.原子表

## 4.原子组

## 5.重复匹配

## 6.全局匹配

## 7.字符方法

## 8.正则方法

## 9.断言匹配

# 14.Promise

## 0.Promise

## 1.问题探讨

## 2.异步状态

## 3.then

## 4.catch

## 5.finally

## 6.实例操作

## 7.链式操作

## 8.扩展接口

## 9.任务队列

## 10.async/await

# 15.任务管理

## 0.任务管理

## 1.实例操作

# 16.Promise核心

## 0.起步构建

## 1.THEN

## 2.链式操作

## 3.返回类型

## 4.RESOLVE

## 5.REJEDCT

## 6.ALL

## 7.RACE

# 17.DOM

## 0.基础知识

操作文档HTML的JS处理方式为DOM 即Document Object Model 文档对象模型。如果对HTML很了解使用DOM并不复杂

浏览器在加载页面是会生成DOM对象，以供我们使用JS控制页面元素

- 文档渲染

  l浏览器会将HTML文本内容进行渲染，并生成相应的JS对象，同时会对不符规则的标签进行处理

  - 浏览器会将标签规范后渲染页面
  - 目的一让页面可以正确呈现
  - 目的二可以生成统一的JS可操作对象
  - 标签修复

## 1.DOCUMENT

## 2.节点属性

## 3.节点集合

## 4.节点关系

## 5.选取借点

## 6.遍历节点

## 7.样式选择器

## 8.动态与静态

## 9.标准属性

## 10.元素特征

## 11.创建节点

## 12.节点内容

## 13.节点管理

## 14.表单控制

## 15.样式管理

# 18.空间坐标

# 19.事件







































































